<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">  
    <title>AngularJS</title>
    <link rel="stylesheet" href="reveal/css/reveal.css">
    <!-- <link rel="stylesheet" href="reveal/css/print/pdf.css"> -->

    <meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/lib/css/github.css">

    <link rel="stylesheet" href="slides-theme/style.css">
    <link rel="stylesheet" href="style.css">
</head>

<body>

<div class="reveal">
<div class="slides">

<section data-markdown data-state="highlight"><script type="text/template">

  # AngularJS
  ![shield](img/angular-shield.svg)

  ### @timruffles
  ### sidekickjs.com

</script>
</section>

<section data-markdown><script type="text/template">
  <h3 style='text-transform:inherit' contenteditable>wifi: hubwestminster / HubWest1</h3>
  <h3 contenteditable> clone/DL: github.com/timruffles/angular-js-class</h3>
</script>
</section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Today

  - Impression of Angular
  - Philosophy: goals, non-goals
  - Guide to Angular + exercises
  - Build something with Angular!

</script></section>

<section>
  
  <script type=cs code-sample>
    <h2>HTML {{ verb }} for web apps!</h2>
    <input ng-model='verb' ng-init='verb = "enhanced"' />
  </script>

</section>

<section data-markdown><script type="text/template">
  
  ## Impression

  - data-binding
  - custom markup - like Dojo
  - very little Javascript (code example was complete)
  - back to Javascript in HTML

</script></section>

<section>
  
  <script type=cs code-sample>
    <h2>Slide on ng, in ng</h2>
    <ul ng-init='thoughts = ["ng - WTH?","bit magic","performance?","expressive"]'>
      <li ng-repeat='thought in thoughts'>
        {{ thought }}
        <a ng-click='thoughts.splice(thoughts.indexOf(thought),1)'>X</a>
      </li>
    </ul>
  </script>

</section>

<section data-markdown><script type="text/template">
  
  ## Goals

  - build out from HTML, not expand JS's job
  - radical testability - no untestable bits
  - 'just Javascript' for model layer

</script></section>

<section data-markdown><script type="text/template">
  ## Solutions

  - extensions to HTML - what you've seen - via directives
  - dependency injection container as module system
  - change watching, not events (like Backbone etc)

</script></section>


<section data-markdown><script type="text/template">

  ## MVC

  - model: what your app does for users
  - view: interative representation of model
  - controller: glue
  - key: seperate what your app does/is: model, how: view + controller

</script></section>


<section data-markdown><script type="text/template">

  ## Angular's MVC

  - model: your Javascript, watched by Angular
  - view: HTML extended via directives
  - controller: Javascript to glue views to models

</script></section>

<section data-markdown><script type="text/template">

  ## How is Angular different?

  - to jQuery/flat JS: much less DOM manipulation, more structure
  - to Backbone: less DOM manipulation, larger goals
  - to old-style JS in HTML: scoped, not arbitrary JS

</script></section>

<section data-markdown><script type="text/template">

  ## Angular's MVW

  - model, view, whatever
  - e.g leaves things up to you
  - contrast with Ember which aims to be complete
  - bring-your-own model, and app superstructure

</script></section>


<section data-markdown data-state=highlight><script type="text/template">

  ## Let's read some code

</script></section>


<section>

  <h2>First Angular M, V & C</h2>

  <script type=code-sample code-sample>
    <div ng-controller=clicking>
      <button ng-click=clicked()>Click me</button>
      <p>You've clicked the button {{counter.clicks}} times.</p>
    </div>
    <code class=controller>
      module.controller('clicking',function($scope) {
        $scope.counter = {clicks: 0};
        $scope.clicked = function() {
          $scope.counter.clicks += 1;
        }
      })
    </code>
  </script>

</section>

<section data-markdown><script type="text/template">

  ## So how does it work?

  - View: Angular has compiled our HTML, attaching directives
  - Controller: passes scopes to controller
  - Model: watched for changes, changes trigger updates to view

</script></section>

<section>

  <h2>Annotated MVC</h2>

  <script type=code-sample code-sample>
    <!-- VIEW -->
    <div ng-controller=clicking>
      <button ng-click=clicked()>Click me</button>
      <p>You've clicked the button {{counter.clicks}} times.</p>
    </div>
    <code class=controller>
      // controller
      module.controller('clicking',function($scope) {
        // very simple model
        $scope.counter = /* model */ {clicks: 0};
        // glue between view & controller
        $scope.clicked = function() {
          $scope.counter.clicks += 1;
        }
      })
    </code>
  </script>

</section>

<section>

  <h2>Need to learn about...</h2>

  <ul>
    <li>Directives
    <li>Controllers
    <li>Scopes
  </ul>

</section>


<section data-markdown data-state=highlight><script type="text/template">
  ## Built in directives
</script></section>

<section data-markdown><script type="text/template">
  ## Not the kitchen sink

  - Angular defines a core set of directives
  - Directives are the view in Angular's MVW
</script></section>

<section data-markdown><script type="text/template">
  ## How to use directives

  - picked up via HTML element attributes or tag names
  - use Angular expressions to bind data from the scope to attributes

</script></section>

<section>
  <h2>e.g <code>ng-repeat</code></h2>

  <script type=code-sample code-sample>
    <ul ng-init='stepsForDirectives = ["choose directive","insert into HTML","configure via attributes, potentially bound to scope"]'>
      <li ng-repeat='step in stepsForDirectives'>
        {{ step }}
      </li>
    </ul>
  </script>

</section>

<section>
  <h2>e.g <code>ng-click</code></h2>

  <script type=code-sample code-sample>
    <div ng-controller=clicking>
      <p>{{ counter.clicks }}</p>
      <button ng-click=clicked()>Click me</button>
    </div>
  </script>
  <pre><code>module.controller('clicking',function($scope) {
  $scope.counter = {clicks: 0};
  $scope.clicked = function() {
    $scope.counter.clicks += 1;
  }
})
  </code></pre>

</section>

<section>
  <h2>e.g <code>ng-show</code></h2>

  <script type=code-sample code-sample>
    <div ng-controller=show>
      <p ng-show=content.visible>{{ content.text }}</p>
      <button ng-click=toggle()>Click me</button>
    </div>
    <code class=controller>
      module.controller('show',function($scope) {
        $scope.content = {visible: true, text: "Now you see me"};
        $scope.toggle = function() {
          $scope.content.visible = !$scope.content.visible;
        }
      });
    </code>
  </script>

</section>

<section data-markdown><script type="text/template">
  
  ## Built-in highlights

  - `ng-hide`, `ng-show`, `ng-if`: control visibility or presence of HTML via expression
  - `ng-include` include HTML code and compile it
  - `ng-class`, `ng-style`, `ng-attributes`: control classnames, style and attrs via expressions

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's use them!

  - exercises/using-built-in-directives

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  ## Controllers
</script></section>

<section data-markdown><script type="text/template">
  
  ## Controller

  - glue between models, other code, and view
  - has access to scope, not DOM

</script></section>

<section data-markdown><script type="text/template">
  ## Controller example

  - here, we've written a method for view to call:

  ```
  module.controller('clicking',function($scope) {
    $scope.user = {clicks: 0};
    $scope.clicked = function() {
      $scope.user.clicks += 1;
    }
  })
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers DO

  - define functions for view to invoke
  - call methods on model/other code

</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers DON'T

  - talk to (or know about) the DOM

</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers get scopes

  - each `ng-controller` directive creates a new scope

</script></section>

<section data-markdown><script type="text/template">
  
  ## Scope hierarchy

<script type='codeExample' code-example>
  <!-- outer scope starts -->
  <div ng-controller='outer'>
    <p>You've clicked {{ user.count }} times</p>
    <!-- inner scope starts -->
    <div ng-controller='inner'>
      <button ng-click='user.count += 1'>Increase</button>
    </div>
  </div>
</script>

</script></section>

<section data-markdown><script type="text/template">
  ## I'm sorry to say...
</script></section>

<section data-markdown><script type="text/template">
  
  ## ...there's lots of opression in Angular

</script></section>

<section data-markdown><script type="text/template">
  
  ![hierarchy](img/scope-hierarchy.png)

</script></section>

<section data-markdown><script type="text/template">
  ## Other directives can create scopes too

  <script type='codeExample' code-example>
    <div ng-controller='outer'>
      <a ng-repeat='user in userList'>
        <!-- a new scope for every user, so
             'user' refers to the right thing -->
        {{ user.name }}
      </a>
    </div>
  </script>

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's have a go!

  - exercises/controllers-scopes

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  ## Digesting scopes

</script></section>

<section data-markdown><script type="text/template">
  ## Scopes: power data-binding
</script></section>

<section data-markdown><script type="text/template">

  ## ...they are

  - an object to bind to
  - organised into parent/child relationships
  - used by controller/view/directives

</script></section>

<section data-markdown><script type="text/template">
  ## ...but how?
</script></section>

<section data-markdown><script type="text/template">
  ## Hierarchy

  - what else in JS have parent/child relationships?
</script></section>

<section data-markdown><script type="text/template">
  ## Objects!

  - the prototype chain
</script></section>

<section data-markdown><script type="text/template">

  ## Scopes are just objects

  - scopes prototypally inherit from parents
  - this makes for intuative cooperation between controllers

</script></section>

<section data-markdown><script type="text/template">
  
  ## Prototypal inheritance


  ```
  var parent = {
    title: "Our lovely app", 
    user: {name: "bob"}
  };
  var child = Object.create(parent)

  child.title // "Our lovely app"
  child.user === parent.user // true
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Okay that was easy...
</script></section>

<section data-markdown><script type="text/template">
  ## ...how does binding work?
</script></section>

<section data-markdown><script type="text/template">
  
  ## `scope.$watch()`

  - all binding goes via `$watch()` internally

  ```javascript
  scope.$watch("user.name",function(newValue,old) {
    // run only when value changes
  });

  scope.$watch(function() {
    // same functionality as above
    return scope.user.name;
  },function(newValue,old) {
    // run only when value changes
  });
  ```

  <script type=a code-example>
    <a>{{ user.name }}</a>
  </script>

</script></section>

<section data-markdown><script type="text/template">
  
  ## `scope.$watch()`

  - defaults to `===`
  - pass `true` to third argument for deep comparison
  - quite slow: avoid on big objects if you can
  - deep uses `angular.copy` to cache objects, so if poss only watch scalars for speed/space

  ```javascript
  watch.last = watch.eq ? copy(value) : value;
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## `scope.$watchCollection()`

  - when watching items in a key-value or ordered collection
  - shallow watches: therefore fires on add, delete and reorder

</script></section>

<section data-markdown><script type="text/template">
  ## Digesting is just about firing watchers
</script></section>

<section data-markdown><script type="text/template">
  
  ## Digest loop

  - `$digest()` is a `Scope` method
  - if value of expression has changed, fires handler
  - handlers update bindings - e.g for `<a ng-repeat='user in users'></a>`

</script></section>

<section data-markdown data-state=highlight><script type="text/template">

  ## Let's do some watching

  - exercises/watching-scope

</script></section>

<section data-markdown><script type="text/template">
  ## `$digest` vs `$apply`
</script></section>

<section data-markdown><script type="text/template">
  ## `$digest`: scope downwards
</script></section>

<section data-markdown><script type="text/template">
  ## `$apply`: `$rootScope` downwards
</script></section>

<section data-markdown><script type="text/template">
  ![digest](img/digest.png)
</script></section>

<section data-markdown><script type="text/template">
  ![apply](img/apply.png)
</script></section>

<section data-markdown><script type="text/template">
  ## Pseudo-code

  - note the `$exceptionHandler`

  ```javascript
  function $apply(expr) {
    try {
      return $eval(expr);
    } catch (e) {
      $exceptionHandler(e);
    } finally {
      $root.$digest();
    }
  }
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$exceptionHandler`

  - by default just logs
  - can override - perhaps to publish it?
</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  ## When does the digest loop run?
</script></section>

<section data-markdown><script type="text/template">
  ## When you tell it to
</script></section>

<section data-markdown><script type="text/template">

  ## `$digest()`

  ```javascript
  angular.injector(["ng"]).invoke(function($rootScope) {

    var scope = $rootScope.$new();
    scope.on = true;
    scope.$watch("on",function(on) {
      console.log("lightbulb now: " + (on ? "on" : "off"))
    });
    // nothing happens, digest hasn't been called
    scope.on = false;
    scope.on = true;
    scope.on = false;
    // will trigger
    scope.$digest()
    // triggers again, $apply = do then digest
    scope.$apply(function() {
      scope.on = true;
    });

  });
  ```

</script></section>


<section data-markdown><script type="text/template">
  ## ...or when a Angular component does
</script></section>

<section data-markdown><script type="text/template">
  ## What's Angular doing here?

  <script type=a code-example>
    <a ng-click='showError("Do not click this button!!")'>Don't click me</a>
  </script>

</script></section>

<section data-markdown><script type="text/template">
  ## What's Angular doing here?

  - wrap your callback with `$apply()`

  <script type=a code-example>
    <a ng-click='showError("Do not click this button!!")'>Don't click me</a>
  </script>

</script></section>

<section data-markdown><script type="text/template">
  ## ng-world, JS-world

  - if we make changes to scope outside of Angular's world we'll need to tell Angular
  - e.g AJAX callback, non-Angular event callback
  - very important when writing your own directives

</script></section>

<section data-markdown><script type="text/template">
  ## Well that's not very magic...
</script></section>

<section data-markdown><script type="text/template">
  ## ...but there are still gotchas
</script></section>

<section data-markdown><script type="text/template">
  ## Never bind to the scope...
</script></section>

<section data-markdown><script type="text/template">
  ## ...bind to an object *on* the scope
</script></section>

<section data-markdown><script type="text/template">
  ## Why?
</script></section>

<section data-markdown><script type="text/template">
  
  ## Sharing data

  - child's own property will hide parent's
  - use objects to share data between scopes

  ```
  var parent = {
    title: "app", 
    user: {name: "bob"}
  };
  var child = Object.create(parent)
  child.title // 'app'

  parent.title = 'fancy app'
  child.title // 'fancy app'

  child.title = 'child'
  parent.title // 'changed again'
  child.title // 'child'
  // we lost link - child now has its own 'title' property

  child.user.name = 'sue'
  child.user.name  // what'll it be?
  parent.user.name  // and here?
  ```

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's try that out

  - exercises/tricky-scopes


</script></section>

<section data-markdown><script type="text/template">
  ## Scope lifecycle

  - scopes don't live forever
  - e.g in a `ng-repeat` when item is deleted
  - listen to `$destroy` event
  - make sure you clean up times etc!
</script></section>

<section data-markdown><script type="text/template">
  ## listen you say?
</script></section>

<section data-markdown><script type="text/template">
  ## Scope's pubSub
</script></section>

<section data-markdown><script type="text/template">
  ## `$emit` and `$broadcast`
</script></section>

<section data-markdown><script type="text/template">
  ## `$emit`
   
  - triggers event on current scope and then back up to root
</script></section>


<section data-markdown><script type="text/template">
  ## `$broadcast`

  - like `$digest`, current scope and down
</script></section>

<section data-markdown><script type="text/template">
  ## Using pubSub

  - more like DOM events than other systems
  - can cancel, see current/target scope etc

  ```javascript
  app.controller("video",function($scope) {
    $scope.$watch = function(video) {
      // up 
      $scope.$emit("watched",video.id);
      // down
      $scope.$broadcast("watched",video.id);
    }
  })
  ```

  ```javascript
  app.controller("watchCount",function($scope) {
    var counts = {};
    $scope.$on("watched",function(event,id) {
      counts[id] = (counts[id] || 0) + 1;
    })
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## How to use

  - I'd suggest: for very scope dependent things
  - e.g no need for controllers to care where event came from
  - For more general use, pick a simpler/faster option

</script></section>

<section data-markdown><script type="text/template">
  
  ## So back to `$destroy`

  ```javascript
  app.controller("watchCount",function($scope,$interval) {
    var tick = $interval(function() {
      // $scope isn't getting GC'd until this
      // function is
    },500);
    $scope.$on("$destroy",function() {
      // frees the callback, and therefore the $scope
      $interval.cancel(tick);
    })
  })
  ```
  

</script></section>


<section data-markdown><script type="text/template">
  
  ## Services

  - unit of functionality
  - defined on modules
  - all singletons
  - have 3 steps: create provider, create factory, create instance via factory
  - 3 steps are to allow configuration before factory, and then to inject instance's dependencies

</script></section>

<section data-markdown><script type="text/template">
  
  ## `angular.module()`

  - Angular's modules group related functionality
  - don't use to group by type - e.g `angular.module("controllers")`
  - not a module-loader, like RequireJS, but a module system
  - can depend on other modules - you'll often depend on `ngRoute` for instance
  - angular is bootstrapped by `ng-app="someModule"`, or `angular.bootstrap(["someModule"])`, passing the modules that define controllers etc found on elements

</script></section>


<section data-markdown><script type="text/template">
  
  ## Why the complexity?

  - One of Angular's goals is radical testability
  - Having all dependencies of providers and instances controllable provides testability
  - not supposed to change how you write your JS code (e.g singletons)
  - Just use to get your code into Angular

</script></section>


<section data-markdown><script type="text/template">
  
  ## Dependency injection

  - How can we intercept `new Date` below?
  - We can't, so we'd like to get the dependency in programmatically
  - Not everything makes sense to put in constructor

  ```
  function SomeObject() {
  }
  SomeObject.prototype.update = function() {
    var someDate = new Date()
  }
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## DI is a goal
</script></section>

<section data-markdown><script type="text/template">
  ## A container is Angular's way of achiving it
</script></section>

<section data-markdown><script type="text/template">
  
  ## `constant`, `value`

  - simple values without dependencies
  - `constant`s can be accessed in configuration blocks
  - values can be dependency injected

  ```
  app.constant("MINUTE",60 * 1000);
  app.value("usersToShow",10);
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## `factory`, `service`

  - provide functionality - normal JS objects and methods
  - both singletons
  - the function you pass is used to create that singleton 

</script></section>

<section data-markdown><script type="text/template">
  
  ## `factory()`

  - `factory`: your function's return value is the singleton

  ```
  app.factory("errorHandling",function($log /*, other deps */) {
    return {
      error: function(msg) {
        $log.error(msg)
      }
    }
  })
  ```

  - so here we should have a `.error()` method exposed on our singleton

  ```
  app.factory("othermodule",function(errorHandling) {
    errorHandling.error("something")
  })
  ```
  
</script></section>


<section data-markdown><script type="text/template">
  
  ## `service()`

  - the result of calling `new yourFunction(dep1,dep2...)` is the singleton

  ```
  app.service("errorHandling",function($log /*, other deps */) {
    this.error = function(msg) {
      $log.error(msg)
    }
  })
  ```

  - again, we'll have a `.error()` method exposed on our singleton

  ```
  app.factory("othermodule",function(errorHandling) {
    errorHandling.error("something")
  })
  ```

</script></section>
  
<section data-markdown><script type="text/template">
  
  ## `factory` vs `service`: FIGHT

  - so: `factory` for returned things, `service` for constructors taking Angular arguments
  - wrapping normal JS libraries: normally use `factory`
  - other JS doesn't take angular dependencies as constructor args

</script></section>

  
<section data-markdown><script type="text/template">
  
  ## Constructors in your code?

  - Absolutely!
  - make a `factory()` that returns the class (or classes)
  - service is level your types have dependencies
  - create classes like normal
  - DON'T go mad and make everything singletons!

</script></section>


<section data-markdown><script type="text/template">
  
  ## `provide()`

  - the root method is `provide` - it has an additional step to allow configuration of the provider (which creates our factory)
  - so the rest are sugar for provide
  - provide returns a config object with, at minimum, `$get`
  - use when you have extra config to perform/expose

</script></section>



<section data-markdown><script type="text/template">
  
  ## How does the magic work?

  - how does Angular know to give right module?

</script></section>

<section data-markdown><script type="text/template">
  
  ## Magic circle explusion

  - parses our function as a string! (really)
  - minification will break, can be specific

  ```
  var hasDeps = function($log) {
  }
  var src = hasDeps.toString() // function($log) {}
  var deps = depsRexp.exec(src)
  // we have our dependencies!
  ```
  ```
  var hasDeps = function($log) {
  }
  hasDeps.$inject = ['$log']

  uglify(hasDeps + "") // function(a) {}, but will still work!
  ```

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  ## A more complete example

  - exercises/crud-mvc

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  ## Filters

</script></section>



<section>
  
  <h2>Filters</h2>

  <ul>
  <li>quick, declarative transformation of output
  <li>works with data-binding
  <li>pure: take data in, return new version
  </ul>

  <script type=cs code-sample>
    <p>Unfiltered: '{{val}}', filtered: '{{val|uppercase}}'</p>
    <input ng-model=val ng-init='val = "foo"'>
  </script>

</section>

<section data-markdown ><script type="text/template">
  
  ## Example filters

  - can work on anything - here an array or a string
  - about simplest thing you can write in Angular!

  ```javascript
  app.filter("everyOther",function() {
    return function alternate(input) {
      return input.filter(function(el,i) {
        return i % 2 == 0
      })
    }
  });
  ```

  ```javascript
  app.filter("titleCase",function() {
    return function titleCase(input) {
      return input.split(" ").map(function(word) {
        return word[0].toUpperCase() + word.slice(1)
      }).join(" ")
    }
  });
  ```

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  ## It still feels a bit Flash 2003...

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  ## ...what about URLs?

</script></section>


<section data-markdown><script type="text/template">
  ## Routes
</script></section>

<section>
<h2>A... module</h2>

<ul>
  <li>not in core
  <li>so we need to include the module
</ul>

<pre>
<code>&lt;script src='vendor/angular/angular-routes.js'>&lt;/script>
</code>
</pre>

<pre><code>var ourModule = angular.module("ourModule",["ngRoute"]);</code></pre>

</section>

<section data-markdown><script type="text/template">
  - trio of services - `location`, `route`, `routeParams`
  - one directive: `ng-view` where content appears
  - we define routes via `$routeProvider`
  - we control how URL works via `$locationProvider` (e.g pushState or hash)
  - our controllers can see current route's params via `$routeParams`

</script></section>

<section data-markdown><script type="text/template">
  
  ## `routeProvider`

  ```
  app.config(function($routeProvider) {
    $routeProvider
      .when("/item/:id",{
        templateUrl: "/tpls/show.html",
        controller: "showCtrl"
      })
      // ... more roots
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## `routeProvider`

  - very powerful
  - e.g can be given promises for dependencies required

</script></section>

<section data-markdown><script type="text/template">
  ## Template

  - either `template` for a HTML string/function returning HTML string
  - or `templateUrl` for a URL to get an HTML string
  - hack: if there's a script tag with `id == templateUrl`, it'll use that
  - we'll need that as we're on a `file://` url
</script></section>

<section data-markdown><script type="text/template">
  
  ## `location`

  ```
  app.config(function($locationProvider) {
    $locationProvider.html5Mode(true);
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## No push state for us...
  - we're on a `file://` url
</script></section>

<section data-markdown><script type="text/template">
  
  ## `routeParams`

  ```
  $routeProvider
  .when("/item/:id",{
    templateUrl: "/tpls/show.html",
    controller: "showCtrl"
  })
  ```

  - How do we access params?

  ```
  app.controller("drawingCreateCtrl",function($scope,$routeParams) {
      routeParams.id
      // use any params defined in route config
  })

  ```

</script></section>

<section data-markdown><script type="text/template">
  ## If there's only one controller for a template...
  - just put it in the template
</script></section>



<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's use them

  - exercises/routes

</script></section>





<section data-markdown data-state=highlight><script type="text/template">
  
  ## Time for... more magic!


</script></section>

<section data-markdown><script type="text/template">
  
  ## Directives

  - The big USP of angular
  - Extend the DOM
  - As simple as preventing default click-behaviour on `a href=''`
  - To whole new widgets, with their own hierarchy of controllers

</script></section>


<section>
  
  <h2>Directives in DOM</h2>

  <ul>
    <li>Can be triggered in many ways: element names (IE9+), classes, attributes, etc
    <li>Can lock down triggers per directive
    <li>e.g `a` directive only available as element name, so augments all `a`s
  </ul>

  <script type=cs code-example>
  app.directive("myDirective",function() {});

  <my-directive></my-directive>
  <div my-directive></div>
  <div class="my-directive"></div>
  <div data-my-directive></div>
  </script>

</section>


<section data-markdown><script type="text/template">
  
  ## Directives in Angular

  - All the cool bits are from directives
  - `ngRepeat`, `ngInclude`, `ngClick` etc all directives
  - So no magic: all tools available to `ng` is available to you

</script></section>


<section data-markdown><script type="text/template">
  
  ## Defining

  - defined on modules as normal
  - return either a config object, or just fn to link to element
  - lots of control: we'll cover a moderately complex case
  - advanced directives: you'll need to look at `$compile`

</script></section>

<section data-markdown><script type="text/template">
  
  ## Define example

  ```javascript
  app.directive("someName",function($location /* injected */) {
    return {
      link: function(scope,el,attrs) {
      }
    }
  });
  // equivalent
  app.directive("someName",function($location /* injected */) {
    return function(scope,el,attrs) {
    }
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## Let's write one

  - execises/first-directive

</script></section>


<section data-markdown><script type="text/template">
  
  ## Templates

  - can specify via `template` for a template string, or `templateUrl`
  - pass `replace: true` to replace the current element with the template

</script></section>

<section data-markdown><script type="text/template">
  ## ...what are isolate scopes?
</script></section>

<section data-markdown><script type="text/template">
  
  ## Directive scopes

  - need to control level of sharing with parent
  - default: shares parent scope
  - in config, `scope: true` to create a new child scope
  - pass a `scope: {}`, create an isolate scope
  - isolate: can control access to individual attrs on parent
</script></section>

<section data-markdown><script type="text/template">

  ## It's all about weird symbols

  ```javascript
  scope: {
    "localName": "=name", // 2 way binding between localName and name
    "href": "@href", // live binding to href on directive's DOM el 
    "dyanmic": "&someExpression" // provides a function wrapper for an expression
  }
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## Directive controllers

  - directives can need controllers too
  - allows multiple directives to communicate & share a parent
  - same job: expose behaviour to scope

</script></section>

<section data-markdown><script type="text/template">
  
## Example

```javascript
app.directive("tourStep",function() {
    return {
      controller: function($scope) {
        // normal controller code - nothing
        // related to DOM
      }
    }
});

app.directive("tourStep",function() {
    return {
      // prefix like '^' controls where controller is
      // looked for: so here looking up DOM to find a directive 
      // called 'tour' with a controller defined
      require: "^tour",
      link: function(scope,el,attrs,controller) {
        // fourth argument becomes our controller
      }
    }
});
```

</script></section>

<section data-markdown><script type="text/template">
  
  ## Transclusion

  - ARGH! Sounds so scary
  - Actually pretty simple: function to clone & comile a chunk of DOM

</script></section>

<section data-markdown><script type="text/template">
  
  ## Transclusion example

  ```javascript
  app.directive("transcludeDemo",function() {
    return {
      transclude: "element",
      template: "<section><div ng-transclude></div></section>",
      compile: function(el,attr,transcludeLink) {
        return function link(scope,el,attrs,controller) {
        }
      }
    }
  });
  ```

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # All together

  - goal: product tour
  - read through code
  - code-to-read/complex-directive

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  # What about HTTP?

</script></section>


<section data-markdown><script type="text/template">
  
  ## Two options

  - `$http` - low-level, direct API
  - `$resource` - JSON-record, for RESTful APIs
  - both use promises

</script></section>

<section data-markdown><script type="text/template">
  ## Promises
</script></section>

<section data-markdown><script type="text/template">

  ## An IOU

  - A promise is a value, returned immediately
  - Later fulfilled or rejected - once
  - Can use before or after value arrives
  - Chain promises together

</script></section>

<section data-markdown><script type="text/template">

  ## Intuition

  ![Promise chain](img/promises.png)

</script></section>

<section data-markdown><script type="text/template">

  ## Promises in practice

  - `.then()` with a function that accepts the value when it arrives
  - `.then()` returns a new promise - for the return value of the function

  ```javascript
  var user = getUser(params["id"]);
  var profile = user.then(getProfile);
  var accountPage = Promise.spread(user,profile).then(accountPageTemplate);

  accountPage.then(
    renderToDom,
    renderErrorMessage
  );
  ```

</script></section>

<section data-markdown><script type="text/template">

  ## Using `then()`

  - for doing things: just pass functions, like a callback
  - for new values: use the returned promise in a chain
  - two jobs: side-effects, values

</script></section>

<section data-markdown><script type="text/template">

  ## In detail

  ```javascript
  var aTennerLater = new Promise(function(resolve) {
    setTimeout(function() { resolve(10) },500)
  });

  var sweets = aTennerLater.then(function(money) {
    if(money < 10) throw new Error("Too little money to fulfil!");
    return { type: "liquorice", value: money };
  });

  var alicesMood = sweets.then(function(sweets) {
    return {
      mood: "Happy! She got " + sweets.value
        + " pounds worth of " + sweets.type
    }
  },function(failureReason) {
    return {
      mood: "Grumpy! No sweets because " + failureReason
    }
  });
  ```

</script></section>


<section data-markdown><script type="text/template">

  ## Can handle multiple dependencies

  - Doesn't require nesting - we have values!
  - we'll be writing spread

  ```javascript
  var user = getUser(params["id"]);
  var profile = user.then(getProfile);
  var accountPage = Promise.all([user,profile])
    .then(function(results) {
      return accountPageTemplate.apply(null,results);
    });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Angular's promises

  - `$q` - is to `Q` as `jQLite` is to `jQuery`
  - most of what you'll need: not broken like `jQuery` promises

  ```javascript
  app.controller("user",function($scope,$q) {
    var deferred = $q.defer();
    var promise = deferred.promise;
    // $q.all to create a promise for resolution
    // of multiple promises
    $q.all([promise,anotherPromise]).then(something);
  })
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Now we can take a look
</script></section>

<section data-markdown><script type="text/template">
  ## `$http` - pretty well `$.ajax`

  - extra methods on promise: `success`, `error`
  - more arguments than `then` gives callbacks

  ```javascript
  $http({method: 'GET', url: '/someUrl'})
    .success(function(data, status, headers, config) {
    })
    .error(function(data, status, headers, config) {
    });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$http`

  - mostly useful due to mockability via `$httpBackend`
  - probably all you need: all common HTTP verbs, `jsonp`
</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource`

  - boiler-plate reduction for HTTP APIs
  - one of the many flavours of REST by default
  - gives you a constructor for instances, and static query methods
  - return empty instances - `{}` or `[]` - for easy data-binding

</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource` in use

  ```
  $scope.users = Users.query()
  // can now use in 'ng-repeat="user in users"'
  $scope.user = new User()
  $scope.user.id = 15
  $scope.user.get(); // will fetch data
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource` configuration

  - configure a specific `$resource`
  - can do lower-level config via same params as `$http`

  ```javascript
  app.factory("User",function($resource) {
    var User = $resource("/api/user/:id",
    // parameter defaults - use @xx to take xx attribute of resource
    {id: '@id'},{
      // extra methods
      'query':  {method:'GET', isArray:true, url: "/api/users"},
      'create': {method:'POST', url: "/api/users"},
    });
    return User;
  })
  ```

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  ## No tests?!

</script></section>

<section data-markdown><script type="text/template">
  
  ## Testing

  - unit testing: isolation
  - end to end testing: integration/functional
  - this is where dependency-injection comes in handy!

</script></section>

<section data-markdown><script type="text/template">
  
  ## Unit tests

  - test one unit of functionality in isolation
  - stub out dependencies for speed/simplicity of testing

  ```
  // app code
  var app = angular.module("app",[]);
  app.filter("first",function(xs) { return xs[0] });

  // test code
  describe("myFilter",function() {
    // setup our injector with the module we want
    beforeEach(module("app"))
    // wrap test code with injector to get at our code
    it("should only return first",inject(function(first) {
      expect(first("hello")).toEqual("h");
    })
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## The core of testing

  - create your component (`setup` or `beforeEach`)
  - assert preconditions
  - do something
  - assert postconditions

</script></section>

<section data-markdown><script type="text/template">
  ## Avoid false positives
</script></section>

<section data-markdown><script type="text/template">
  
  ## Testing: tools

  - test framework: mocha, Jasmine
  - test server/runner: Karma
  - assertions: chai, referree

</script></section>

<section data-markdown><script type="text/template">
  ## For today
  - Jasmine, test framework, runner and assertions
  - BDD style for assertions and suite
</script></section>

<section data-markdown><script type="text/template">
  
  ## Testing: taste

  - BDD: write test names in sentences
  - hierarchical
  - also assertions

  ```javascript
  describe("ng-click",function() {

    beforeEach(function() {})
    it("evaluates its expression when clicked",function() {})

    describe("when something else happens",function() {
      beforeEach(function() {})
      // nested
    })
  })
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## What does Angular change?
</script></section>

<section data-markdown><script type="text/template">
  ## How we wrap our code
</script></section>

<section data-markdown><script type="text/template">
  ## So... how do we unwrap it?
</script></section>

<section data-markdown><script type="text/template">
  
  ## `module()`

  - sets up injector to include module(s)
  - or to stub dependencies

  ```
  var moduleSettingFunction = module("app")
  module("app",function($provide) {
    // here we use $provide just like our module
    // allowing us to override factories, values etc
    $provide.value("something",override);
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## `inject()`

  - runs function with dependencies taken from module(s)

</script></section>

<section data-markdown><script type="text/template">
  ## What do we want to inject?
</script></section>

<section data-markdown><script type="text/template">
  ## Fake versions of services
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks n stubs
</script></section>

<section data-markdown><script type="text/template">
  ## Both fakes
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks: function voyeurism

  ```javascript
  var spy = Jasmine.createSpy("spyName");
  spy("Howdy!!!");
  expect(spy).toHaveBeenCalledWith("hello");
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks: asserting call behaviour
</script></section>

<section data-markdown><script type="text/template">
  ## Stubs

  - replace dependencies of a unit

  ```javascript
  function simpleCode(getAnswerFromTelescope) {
    var number = getAnswerFromTelescope();
    // we just want to test this bit
    return number + 1;
  }
  function getAnswerFromTelescope() {
    // horribly slow
    // non-deterministic
    return 42;
  }

  expect(simpleCode(function() { return 1 })).toBe(2)
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks are tests, stubs support tests
</script></section>

<section data-markdown><script type="text/template">
  ## Both are fakes
</script></section>

<section data-markdown><script type="text/template">
  
  ## Let's test drive something

  - implement a tracking system
  - `event(eventName)` counts the number of times its invoked with a given event
  - `save()` fires a `HTTP POST` with the currently tracked events

  ```javascript
  app.controller("user",function($scope,tracking,$interval) {
    $scope.$watch = function() {
      tracking.event("watch");
    }
    $interval(function() {
      tracking.save();
    },5000);
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## You'll want to mock out `$http`
</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  ## Your first test

  - exercises/first-test

</script></section>

<section data-markdown><script type="text/template">
  ## That wasn't very radical
</script></section>

<section data-markdown><script type="text/template">
  ## ...what about the hard parts?
</script></section>

<section data-markdown><script type="text/template">
  ## Directives
</script></section>

<section data-markdown><script type="text/template">
  ## What's required?

  - compile a template containing our directive
  - get access to the `scope` so we can set data/fire events
  - check if directive worked
</script></section>

<section data-markdown><script type="text/template">
  ## Testing directives

  ```javascript 
  describe("notifications",function() {
    var $compile;
    var $rootScope;

    beforeEach(inject(function(_$rootScope_,_$compile_) {
      $compile = _$compile_; // _aService_ avoids shadowing var aService
      $rootScope = _$rootScope_;
    }));

    it("sets the message as visible on notify",function(notifications) {
      var el = $compile("<div><div notifications></div></div>")($rootScope);
      
      $rootScope.$broadcast("notify","something");
      $rootScope.$apply();
      
      expect(el.find(".notification-content.ng-hide").length)
        .toBe(0,"should be visible");
    });
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## OK... how about controllers?
</script></section>

<section data-markdown><script type="text/template">
  ## Testing controllers
  ```javascript
  describe("drawingListItem controller",function() {
    var controller;
    var $scope;

    beforeEach(inject(function($rootScope,$controller) {
      $scope = $rootScope.$new();

      controller = $controller('drawingListItem',{
        $scope: $scope
      });
      $scope.$apply();
    }));

    it('saves drawing after the name has been changed', inject(function($q) {
      spyOn($scope.drawing,"$save").andReturn($q.when(true));
      $scope.$apply(function() {
        $scope.drawing.name = "foo";
      }); 
      expect($scope.drawing.$save).toHaveBeenCalled();
    }));
  });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## If your controllers don't talk to DOM...
</script></section>

<section data-markdown><script type="text/template">
  ## ...testing them is easy
</script></section>

<section data-markdown><script type="text/template">
  
  ## Round-up

  - AngularJS is a MVW framework
  - Bring your own model
  - Extend the DOM with directives, use to create your view
  - Controllers write behaviour for view to use, and expose model
  - It's so testable there's just no excuse

</script></section>

<section data-markdown><script type="text/template">
  ## So...
</script></section>

<section data-markdown><script type="text/template">
  ## Time to build something complete!

  - exercises/complete-example
</script></section>


<section data-markdown><script type="text/template">
  
  ## Next steps

  - Rebuild TodoMVC, or other small CRUD project
  - UI router
  - Release a custom directive

</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  
  # That's a wrap!

</script></section>


<section data-markdown data-state=highlight><script type="text/template">

  ## Thanks!

  <br />
  <br />
  <br />

  ### @timruffles
  ### ask for SidekickJS beta + discount :)

</script></section>


</div>
</div>

<script src="angular.js"></script>
<script src="demo.js"></script>
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>

  var hljsDeferred;
  var hljsPromise;
  var mdDeferred;
  var mdPromise;

  angular.injector(["ng"]).invoke(function($q) {
    hljsDeferred = $q.defer();
    hljsPromise = hljsDeferred.promise;
    mdDeferred = $q.defer();
    mdPromise = mdDeferred.promise;
  });

  Reveal.initialize({

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
        { src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); }, callback: mdDeferred.resolve },

        // Syntareveal/x highlight for <code> elements
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { 
              hljs.initHighlightingOnLoad(); 
              hljsDeferred.resolve();
          } },

        // Zoom reveal/in and out with Alt+click
        { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speakreveal/er notes
        { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remotreveal/e control your reveal.js presentation using a touch device
        // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
    ]

  });

  Reveal.addEventListener( 'ready', function( event ) {
    angular.injector(["ng"]).invoke(function($q) {
      $q.all([hljsPromise,mdPromise]).then(function() {
        angular.bootstrap(document.body,["slides"]);
        angular.injector(["ng","slides"]).invoke(function($compile,$rootScope) {
          [].forEach.call(document.querySelectorAll("section[data-markdown]"),function(slide) {
            $compile(slide)($rootScope)
          })
        })
      })
    })
  });
  
</script>
</body>
]/html>
