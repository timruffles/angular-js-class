<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">  
    <title>AngularJS</title>
    <link rel="stylesheet" href="reveal/css/reveal.css">
    <!-- <link rel="stylesheet" href="reveal/css/print/pdf.css"> -->

    <meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/lib/css/github.css">

    <link rel="stylesheet" href="slides-theme/style.css">
    <link rel="stylesheet" href="style.css">
</head>

<body>

<div class="reveal">
<div class="slides">

<section data-markdown data-state="highlight"><script type="text/template">

  # AngularJS
  ![shield](img/angular-shield.svg)

</script>
</section>

<section data-markdown><script type="text/template">
  <h3 style='text-transform:inherit' contenteditable>wifi: ??? / ???</h3>
  <h3 contenteditable> clone/DL: github.com/timruffles/angular-js-class</h3>
</script>
</section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Today

  - Angular's ideology
  - Angular's directives
  - Controllers
  - Controller/view interaction: forms + filters
  - Services
  - Routing
  - Directives
  - HTTP + promises

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Tomorrow

  - data-binding in depth
  - scopes considered
  - application structure
  - writing directives
  - testing

</script></section>

<section>


  <script type=code-sample code-sample>
    <div ng-controller=verb>
      <h2>HTML {{ verb }} for web apps!</h2>
      <input ng-model='verb'/>
    </div>
    <code class=controller>
      module.controller('verb',function($scope) {
        $scope.verb = "enhanced";
      })
    </code>
  </script>
  
</section>

<section>
  <script type=code-sample code-sample>
    <div ng-controller=repeat>
      <h2>Slide on ng, in ng</h2>
      <ul >
        <li ng-repeat='thought in thoughts'>
          {{ thought }}
          <a ng-click='remove(thought)'>X</a>
        </li>
      </ul>
    </div>
    <code class=controller>
      module.controller('repeat',function($scope) {
        $scope.thoughts = ["ng - WTH?","bit magic","expressive"];
        $scope.remove = function(thought) {
          $scope.thoughts.splice($scope.thoughts.indexOf(thought),1)
        };
      });
    </code>
  </script>
</section>

<section data-markdown><script type="text/template">
  
  ## Impression

  - data-binding
  - custom markup - like Dojo
  - very little Javascript (code example was complete)

</script></section>

<section data-state=title data-markdown><script type="text/template">
  ## Angular-ism
</script></section>

<section data-markdown><script type="text/template">
  ## Big HTML
  - make HTML a language fit for web-apps
</script></section>
<section data-markdown><script type="text/template">
  ## Radical testability
  - no code left behind
  - make code ask for its dependencies, so we can fake it easily in tests
</script></section>
<section data-markdown><script type="text/template">
  ## 'Give us back Javascript'
  - plain JS where possible
  - watch changes in your plain JS data
</script></section>

<section data-markdown><script type="text/template">
  ## Angular-ism manifesto
  - Big HTML
  - 100% testable
  - 'just JS' for models
</script></section>

<section data-state=title data-markdown><script type="text/template">
  ## MVC
</script></section>

<section data-markdown><script type="text/template">
  ## Identify common responsibilities
</script></section>

<section data-markdown><script type="text/template">
  ## Each bit of code specialises
</script></section>

<section data-markdown><script type="text/template">
  ## Model
  - what your app does for users
</script></section>
<section data-markdown><script type="text/template">
  ## View
  - interactive representation of model
</script></section>
<section data-markdown><script type="text/template">
  ## Controller
  - glue
  - exposes commands to view that modify model
</script></section>

<section data-markdown><script type="text/template">
  ## Biggest idea
  - separate what your app does/is: model, how: view + controller
  - and keep going: separate how you persist model from model... etc
</script></section>

<section data-markdown><script type="text/template">
  ## MVC
  - model: your model of problem domain
  - view: presentation & controls
  - controller: glue, commands
</script></section>

<section data-state=title data-markdown><script type="text/template">
  ## Angular's MVC
</script></section>

<section data-markdown><script type="text/template">
  ## Model
  - your Javascript, watched by Angular

  ```javascript
  var players = [{id:1,score: 10},{id:2, score:20}];
  ```

  ```javascript
  function BankAccount(balance) {
    this._balance = balance;
  }
  ```
</script></section>
<section data-markdown><script type="text/template">
  ## View
  -  HTML extended via directives
  - e.g `ng-repeat`
  - data-binding
  - filters: transform model

</script></section>
<section data-markdown><script type="text/template">
  ## Controller
  - Javascript to glue views to models

  ```javascript
  module.controller('repeat',function($scope) {
    $scope.thoughts = ["ng - WTH?","bit magic","expressive"];
    $scope.remove = function(thought) {
      $scope.thoughts.splice($scope.thoughts.indexOf(thought),1)
    };
  });
  ```

</script></section>

<section>

  <h2>Angular M, V & C</h2>

  <script type=code-sample code-sample>
    <div ng-controller=clicking>
      <button ng-click=clicked()>Click me</button>
      <p>You've clicked the button {{counter.clicks}} times.</p>
    </div>
    <code class=controller>
      module.controller('clicking',function($scope) {
        $scope.counter = {clicks: 0};
        $scope.clicked = function() {
          $scope.counter.clicks += 1;
        }
      })
    </code>
  </script>

</section>

<section data-markdown><script type="text/template">
  ## Angular WVC
  - model: whatever
  - view: directives and templates
  - controller: `controller()`, `scope`
</script></section>

<section>
  <h2>The plan</h2>
  <ul>
    <li>Directives - see something
    <li>Controllers &amp; scopes - get data/behaviour into it
    <li>Module system - enabling testing
    <li>Routes and HTTP
    <li>Testing - testing all of the above
  </ul>
</section>


<section data-markdown data-state=title><script type="text/template">
  ## Built in directives
</script></section>

<section data-markdown><script type="text/template">
  ## Not the kitchen sink

  - Angular defines a core set of directives
  - Directives are the view in Angular's MVW
</script></section>

<section data-markdown><script type="text/template">
  ## How to use directives

  - picked up via HTML element attributes or tag names
  - use Angular expressions to bind data from the scope to attributes

</script></section>

<section>
  <h2>e.g <code>ng-repeat</code></h2>

  <script type=code-sample code-sample>
    <ul ng-init='stepsForDirectives = ["choose directive","insert into HTML","configure via attributes, potentially bound to scope"]'>
      <li ng-repeat='step in stepsForDirectives'>
        {{ step }}
      </li>
    </ul>
  </script>

</section>

<section>
  <h2>e.g <code>ng-click</code></h2>

  <script type=code-sample code-sample>
    <div ng-controller=clicking>
      <p>{{ counter.clicks }}</p>
      <button ng-click=clicked()>Click me</button>
    </div>
  </script>
  <pre><code>module.controller('clicking',function($scope) {
  $scope.counter = {clicks: 0};
  $scope.clicked = function() {
    $scope.counter.clicks += 1;
  }
})
  </code></pre>

</section>

<section>
  <h2>e.g <code>ng-show</code></h2>

  <script type=code-sample code-sample>
    <div ng-controller=show>
      <p ng-show=content.visible>{{ content.text }}</p>
      <button ng-click=toggle()>Click me</button>
    </div>
    <code class=controller>
      module.controller('show',function($scope) {
        $scope.content = {visible: true, text: "Now you see me"};
        $scope.toggle = function() {
          $scope.content.visible = !$scope.content.visible;
        }
      });
    </code>
  </script>

</section>

<section data-markdown><script type="text/template">
  
  ## Built-in highlights

  - `ng-hide`, `ng-show`, `ng-if`: control visibility or presence of HTML via expression
  - `ng-include` include HTML code and compile it
  - `ng-class`, `ng-style`, `ng-attributes`: control classnames, style and attrs via expressions

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's use them!

  - exercises/using-built-in-directives

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## Controllers
</script></section>

<section data-markdown><script type="text/template">
  
  ## Controller

  - glue between models, other code, and view
  - has access to scope, not DOM

</script></section>

<section data-markdown><script type="text/template">
  ## Controller example

  - here, we've written a method for view to call:

  ```
  module.controller('clicking',function($scope) {
    $scope.user = {clicks: 0};
    $scope.clicked = function() {
      $scope.user.clicks += 1;
    }
  })
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers DO

  - define functions for view to invoke
  - call methods on model/other code

</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers DON'T

  - talk to (or know about) the DOM

</script></section>


<section data-markdown><script type="text/template">
  
  ## If controllers don't do it, who does?

</script></section>

<section data-markdown><script type="text/template">
  
  ## Forms

  - view: input widgets
  - controller: handle submission

</script></section>

<section data-markdown><script type="text/template">
  
  ## Directives involved

  - `form` - like `a` it's an element directive
  - `ng-submit`
  - `ng-model`
  - `input`

</script></section>

<section data-markdown><script type="text/template">
  
  ## Simple form

  - creates `scope.signupForm` with the form object
  - will assign to `user` object on scope
  - ng shims most HTML5 validators

  <script type=cs code-example>
    <form name=signupForm ng-submit=signup()>
      <input name=username ng-model=user.name required>
      <input name=password type=passsword
             ng-model=user.password required>
      <button>Buy</button>
    </form>
  </script>

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's try that out

  - exercises/forms

</script></section>


<section data-markdown data-state=title><script type="text/template">
  ## Filters
</script></section>

<section>
  
  <h2>Filters</h2>

  <ul>
  <li>quick, declarative transformation of output
  <li>works with data-binding
  <li>pure: take data in, return new version
  </ul>

  <script type=cs code-sample>
    <p>Unfiltered: '{{val}}', filtered: '{{val|uppercase}}'</p>
    <input ng-model=val ng-init='val = "foo"'>
  </script>

</section>

<section data-markdown ><script type="text/template">
  
  ## Example filters

  - can work on anything - here an array or a string
  - about simplest thing you can write in Angular!

  ```javascript
  app.filter("everyOther",function() {
    return function alternate(input) {
      return input.filter(function(el,i) {
        return i % 2 == 0
      })
    }
  });
  ```

  ```javascript
  app.filter("titleCase",function() {
    return function titleCase(input) {
      return input.split(" ").map(function(word) {
        return word[0].toUpperCase() + word.slice(1)
      }).join(" ")
    }
  });
  ```

</script></section>


<section data-markdown><script type="text/template">
  ## Hierarchy of modules interacting
</script></section>

<section data-markdown><script type="text/template">
  
  ## Controllers get scopes

  - each `ng-controller` directive creates a new scope
  - scope is a child of current scope

</script></section>

<section data-markdown><script type="text/template">
  ## Use scopes to organise data/behaviour
</script></section>

<section data-markdown><script type="text/template">
  
  ## Scope hierarchy

<script type='codeExample' code-example>
  <!-- outer scope starts -->
  <div ng-controller='outer'>
    <p>You've clicked {{ user.count }} times</p>
    <!-- inner scope starts -->
    <div ng-controller='inner'>
      <button ng-click='user.count += 1'>Increase</button>
    </div>
  </div>
</script>

</script></section>

<section data-markdown><script type="text/template">
  ## Other directives can create scopes too

  <script type='codeExample' code-example>
    <div ng-controller='outer'>
      <a ng-repeat='user in userList'>
        <!-- a new scope for every user, so
             'user' refers to the right thing -->
        {{ user.name }}
      </a>
    </div>
  </script>

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's have a go!

  - exercises/controllers-scopes

</script></section>


<section data-state=title data-markdown><script type="text/template">
  ## Services, and modules
</script></section>

<section data-markdown><script type="text/template">
  ## What on earth is a service?
</script></section>

<section data-markdown><script type="text/template">
  ## A service is...
  - some code
  - THAT IS ALL!!!
</script></section>

<section data-markdown><script type="text/template">
  ## e.g Three 'services'

  ```javascript
  var NUMBER_OF_ROWS_TO_DISPLAY = 10;
  
  $.ajax = function() { /**/ };

  function User(name) {
    this._name = name;
  }
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Services changes one thing...
</script></section>

<section data-markdown><script type="text/template">
  ## How one bit of code accesses another
</script></section>

<section data-markdown><script type="text/template">
  
  ## Dependency injection

  - How can we intercept `new Date` below?
  - We can't, so we'd like to get the dependency in programmatically
  - Not everything makes sense to put in constructor

  ```
  function SomeObject() {
  }
  SomeObject.prototype.update = function() {
    var someDate = new Date()
  }
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## DI is a goal
</script></section>

<section data-markdown><script type="text/template">
  ## Services are Angular's way of achieving it
</script></section>


<section data-markdown><script type="text/template">
  ## Services live in modules
</script></section>

<section data-markdown><script type="text/template">
  
  ## `angular` <br> `.module()`

  - Angular's modules group related functionality
  - *not* a module-*loader*, like RequireJS, but a module *system*

</script></section>

<section data-markdown><script type="text/template">
  
  ## Bootstrapping

  - angular is bootstrapped by `ng-app="someModule"`, or `angular.bootstrap(someElement,["someModule"])`,
  - passing the modules that define controllers etc found on elements

</script></section>

<section data-markdown><script type="text/template">
  ## We define services with dependencies with...
</script></section>

<section data-markdown><script type="text/template">
  
  ## `factory()`

  - `factory`: your function's return value is your service

  ```javascript
  app.factory("errorHandling",function($log /*, other deps */) {
    return {
      error: function(msg) {
        $log.error(msg)
      }
    }
  })
  ```

  - so here we should have a `.error()` method exposed on our singleton

  ```
  app.factory("othermodule",function(errorHandling) {
    errorHandling.error("something")
  })
  ```
  
</script></section>

<section data-markdown><script type="text/template">
  ## We define services without dependencies with...
</script></section>


<section data-markdown><script type="text/template">
  
  ## `value()`

  - `value`: the thing passed to `value()` is the service

  ```javascript
  app.value("adminRole","ADMIN-USER");
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## So: move code, define dependencies
</script></section>

<section data-markdown><script type="text/template">
  
  ## How does the magic work?

  - how does Angular know to give right module?

</script></section>

<section data-markdown><script type="text/template">
  
  ## REGEX (like all good magic)

  - parses our function as a string!
  - minification breaks: transform in build

  ```
  var hasDeps = function($log) {
  }
  var src = hasDeps.toString() // function($log) {}
  var deps = depsRexp.exec(src)
  // we have our dependencies!
  ```
  ```
  var hasDeps = function($log) {
  }
  hasDeps.$inject = ['$log']

  uglify(hasDeps + "") // function(a) {}, but will still work!
  ```

</script></section>



<section data-markdown><script type="text/template">
  ## We're ready for the big time!
</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  ## A more complete example

  - exercises/crud-mvc

</script></section>



<section data-markdown data-state=title><script type="text/template">
  
  ## This is a web app, so...

</script></section>

<section data-markdown data-state=title><script type="text/template">
  
  ## ...what about URLs?

</script></section>


<section data-markdown><script type="text/template">
  ## Routes
</script></section>

<section>
<h2>A... module</h2>

<ul>
  <li>not in core, so we need to include
  <li>gives us lots of services
</ul>

<pre>
<code>&lt;script src='vendor/angular/angular-routes.js'>&lt;/script>
</code>
</pre>

<pre><code>var ourModule = angular.module("ourModule",["ngRoute"]);</code></pre>

</section>

<section data-markdown><script type="text/template">
  ## Many parts, but all simple
</script></section>

<section data-markdown><script type="text/template">
  - trio of services - `location`, `route`, `routeParams`
  - one directive: `ng-view` where content appears
</script></section>

<section data-markdown><script type="text/template">
  - we define routes via `$routeProvider`
  - we control how URL works via `$locationProvider` (e.g pushState or hash)
  - our controllers can see current route's params via `$routeParams`
</script></section>

<section data-markdown><script type="text/template">
  
  ## `routeProvider`

  ```
  app.config(function($routeProvider) {
    $routeProvider
      .when("/item/:id",{
        templateUrl: "/tpls/show.html",
        controller: "showCtrl"
      })
      // ... more roots
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## `routeProvider`

  - very powerful
  - e.g can be given promises for dependencies required

</script></section>

<section data-markdown><script type="text/template">
  ## Template

  - either `template` for a HTML string/function returning HTML string
  - or `templateUrl` for a URL to get an HTML string
  - hack: if there's a script tag with `id == templateUrl`, it'll use that
  - we'll need that as we're on a `file://` url
</script></section>

<section data-markdown><script type="text/template">
  
  ## `location`

  ```
  app.config(function($locationProvider) {
    $locationProvider.html5Mode(true);
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## No push state for us...
  - we're on a `file://` url
</script></section>

<section data-markdown><script type="text/template">
  
  ## `routeParams`

  ```
  $routeProvider
  .when("/item/:id",{
    templateUrl: "/tpls/show.html",
    controller: "showCtrl"
  })
  ```

  - How do we access params?

  ```
  app.controller("showCtrl",function($scope,$routeParams) {
    // use any params defined in route config
    // from url `/item/:id`
    var itemId = routeParams.id
  })

  ```

</script></section>

<section data-markdown><script type="text/template">
  ## If there's only one controller for a template...
  - just put it in the template
</script></section>



<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's use them

  - exercises/routes

</script></section>


<section data-markdown data-tags=inside data-state=title><script type="text/template">
  
  ## Time for... more magic!


</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  
  ## Directives

  - The big USP of angular
  - Extend the DOM
  - As simple as preventing default click-behaviour on `a href=''`
  - To whole new widgets, with their own hierarchy of controllers

</script></section>


<section data-tags=inside>
  
  <h2>Directives in DOM</h2>

  <ul>
    <li>Invoked many ways: element names (IE9+), classes, attributes, etc
    <li>Can lock down triggers per directive (default just attr)
    <li>e.g `a` directive only available as element name, so augments all `a`s
  </ul>

  <script type=cs code-example>
  app.directive("myDirective",function() {});

  <my-directive></my-directive>
  <div my-directive></div>
  <div class="my-directive"></div>
  <div data-my-directive></div>
  </script>

</section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directives in Angular

  - All the cool bits are from directives
  - `ngRepeat`, `ngInclude`, `ngClick` etc all directives
  - So no magic: all tools available to `ng` is available to you

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## Defining

  - defined on modules as normal
  - return either a config object, or just fn to link to element
  - lots of control: we'll cover a moderately complex case
  - advanced directives: you'll need to look at `$compile`

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Define example

  ```javascript
  app.directive("someName",function($location /* injected */) {
    return {
      link: function(scope,el,attrs) {
      }
    }
  });
  // equivalent
  app.directive("someName",function($location /* injected */) {
    return function(scope,el,attrs) {
    }
  });
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Let's write one

  - execises/first-directive

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## Templates

  - can specify via `template` for a template string, or `templateUrl`
  - pass `replace: true` to replace the current element with the template

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ...what are isolate scopes?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directive scopes

  - need to control level of sharing with parent
  - default: shares parent scope
  - in config, `scope: true` to create a new child scope
  - pass a `scope: {}`, create an isolate scope
  - isolate: can control access to individual attrs on parent
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## It's all about weird symbols

  ```javascript
  scope: {
    "localName": "=name", // 2 way binding between localName and name
    "href": "@href", // live binding to href on directive's DOM el 
    "dyanmic": "&someExpression" // provides a function wrapper for an expression
  }
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directive controllers

  - directives can need controllers too
  - allows multiple directives to communicate & share a parent
  - same job: expose behaviour to scope

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
## Example

```javascript
app.directive("tourStep",function() {
    return {
      controller: function($scope) {
        // normal controller code - nothing
        // related to DOM
      }
    }
});

app.directive("tourStep",function() {
    return {
      // prefix like '^' controls where controller is
      // looked for: so here looking up DOM to find a directive 
      // called 'tour' with a controller defined
      require: "^tour",
      link: function(scope,el,attrs,controller) {
        // fourth argument becomes our controller
      }
    }
});
```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Transclusion

  - ARGH! Sounds so scary
  - Actually pretty simple: function to clone & comile a chunk of DOM

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Transclusion example

  ```javascript
  app.directive("transcludeDemo",function() {
    return {
      transclude: "element",
      template: "<section><div ng-transclude></div></section>",
      compile: function data-tags=inside(el,attr,transcludeLink) {
        return function link(scope,el,attrs,controller) {
        }
      }
    }
  });
  ```

</script></section>

<section data-markdown  data-tags=inside data-state=highlight><script type="text/template">
  
  ## All together

  - goal: product tour
  - read through code
  - code-to-read/complex-directive

</script></section>


<section data-markdown data-state=title><script type="text/template">
  
  ## What about HTTP?

</script></section>


<section data-markdown><script type="text/template">
  
  ## Two options

  - `$http` - low-level, direct API
  - `$resource` - JSON-record, for RESTful APIs
  - both use promises

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Promises
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## An IOU

  - A promise is a value, returned immediately
  - Later fulfilled or rejected - once
  - Can use before or after value arrives
  - Chain promises together

</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Intuition

  ![Promise chain](img/promises.png)

</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Promises in practice

  - `.then()` with a function that accepts the value when it arrives
  - `.then()` returns a new promise - for the return value of the function

  ```javascript
  var user = getUser(params["id"]);
  var profile = user.then(getProfile);
  var accountPage = Promise.spread(user,profile).then(accountPageTemplate);

  accountPage.then(
    renderToDom,
    renderErrorMessage
  );
  ```

</script></section>


<section data-markdown data-tags=inside><script type="text/template">

  ## `then` is either:

  - An action to take when promise settles
  - A recipe for a new promised value

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## Angular's promises

  - `$q` - is to `Q` as `jQLite` is to `jQuery`
  - most of what you'll need: not broken like `jQuery` promises

  ```javascript
  app.controller("user",function($scope,$q) {
    var deferred = $q.defer();
    var promise = deferred.promise;
    // $q.all to create a promise for resolution
    // of multiple promises
    $q.all([promise,anotherPromise]).then(something);
  })
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Now we can take a look
</script></section>

<section data-markdown><script type="text/template">
  ## `$http` - pretty well `$.ajax`

  - extra methods on promise: `success`, `error`
  - more arguments than `then` gives callbacks

  ```javascript
  $http({method: 'GET', url: '/someUrl'})
    .success(function(data, status, headers, config) {
    })
    .error(function(data, status, headers, config) {
    });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$http`

  - mostly useful due to mockability via `$httpBackend`
  - probably all you need: all common HTTP verbs, `jsonp`
</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource`

  - boiler-plate reduction for HTTP APIs
  - one of the many flavours of REST by default
  - gives you a constructor for instances, and static query methods
  - return empty instances - `{}` or `[]` - for easy data-binding

</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource` in use

  ```
  $scope.users = Users.query()
  // can now use in 'ng-repeat="user in users"'
  $scope.user = new User()
  $scope.user.id = 15
  $scope.user.get(); // will fetch data
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## `$resource` configuration

  - configure a specific `$resource`
  - can do lower-level config via same params as `$http`

  ```javascript
  app.factory("User",function($resource) {
    var User = $resource("/api/user/:id",
    // parameter defaults - use @xx to take xx attribute of resource
    {id: '@id'},{
      // extra methods
      'query':  {method:'GET', isArray:true, url: "/api/users"},
      'create': {method:'POST', url: "/api/users"},
    });
    return User;
  })
  ```
</script></section>

<section data-markdown><script type="text/template">
  
  ## Round-up

  - Have your code specialise via MVC
  - Bring your own model
  - Big HTML!
  - Controllers write to scope, views read
  - Services are a module system concept only

</script></section>

<section data-markdown><script type="text/template">
  ## So...
</script></section>

<section data-markdown><script type="text/template">
  ## Time to build something complete!

  - exercises/complete-example
  - uses fake HTTP, so can 'persist' data
</script></section>












<section data-mardown data-state=title><script type="text/template">

  ## Day two

  - data-binding in depth
  - scopes considered
  - application structure
  - writing directives
  - testing

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## How do scopes work?
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## Scopes: power data-binding
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## ...they are

  - an object to bind to
  - organised into parent/child relationships
  - used by controller/view/directives

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ...but how?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Hierarchy

  - what else in JS have parent/child relationships?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Objects!

  - the prototype chain
</script></section>

<section data-markdown><script type="text/template">

  ## Scopes are just objects

  - scopes prototypally inherit from parents
  - this makes for intuitive cooperation between controllers

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Prototypal inheritance

  ```
  var parent = {
    title: "Our lovely app", 
    user: {name: "bob"}
  };
  var child = Object.create(parent)

  child.title // "Our lovely app"
  child.user === parent.user // true
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Okay that was easy...
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ...how does binding work?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `scope.$watch()`

  - all binding goes via `$watch()` internally

  ```javascript
  scope.$watch("user.name",function(newValue,old) {
    // run only when value changes
  });

  scope.$watch(function() {
    // same functionality as above
    return scope.user.name;
  },function(newValue,old) {
    // run only when value changes
  });
  ```

  <script type=a code-example>
    <a>{{ user.name }}</a>
  </script>

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `scope.$watch()`

  - defaults to `===`
  - pass `true` to third argument for deep comparison
  - deep uses `angular.copy` to cache objects, so if poss only watch scalars for speed/space

  ```javascript
  // 'eq' means deep, so you can see it copies to store last value
  watch.last = watch.eq ? copy(value) : value;
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `scope.$watchCollection()`

  - when watching items in a key-value or ordered collection
  - shallow watches: therefore fires on add, delete and reorder

</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## Digesting is just about firing watchers
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Digest loop

  - `$digest()` is a `Scope` method
  - if value of expression has changed, fires handler
  - handlers update bindings - e.g for `<a ng-repeat='user in users'></a>`

</script></section>

<section data-markdown  data-tags=inside data-state=highlight><script type="text/template">

  ## Let's do some watching

  - exercises/watching-scope

</script></section>



<section data-markdown  data-tags=inside data-state=title><script type="text/template">
  ## When does the digest loop run?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## When you tell it to
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## `$digest()`

  ```javascript
  angular.injector(["ng"]).invoke(function($rootScope) {

    var scope = $rootScope.$new();
    scope.on = true;
    scope.$watch("on",function(on) {
      console.log("lightbulb now: " + (on ? "on" : "off"))
    });

    scope.on = false;
    scope.on = true;
    scope.on = false;

    scope.$digest()

    scope.$apply(function() {
      scope.on = true;
    });

  });
  ```

</script></section>


<section data-tags=inside data-markdown><script type="text/template">
  ## ...or when a Angular component does
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## What's Angular doing here?

  <script type=a code-example>
    <a ng-click='showError("Do not click this button!!")'>Don't click me</a>
  </script>

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## What's Angular doing here?

  - wrap your callback with `$apply()`

  <script type=a code-example>
    <a ng-click='showError("Do not click this button!!")'>Don't click me</a>
  </script>

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## ng-world, JS-world

  - if we make changes to scope outside of Angular's world we'll need to tell Angular
  - e.g AJAX callback, non-Angular event callback
  - very important when writing your own directives

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$digest` vs `$apply`
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$digest`: scope downwards
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## `$apply`: `$rootScope` downwards
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ![digest](img/digest.png)
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ![apply](img/apply.png)
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Pseudo-code

  - note the `$exceptionHandler`

  ```javascript
  function $apply(expr) {
    try {
      return $eval(expr);
    } catch (e) {
      $exceptionHandler(e);
    } finally {
      $root.$digest();
    }
  }
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$exceptionHandler`

  - by default just logs
  - can override - perhaps to publish it?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Well that's not very magic...
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ...but there are still gotchas
</script></section>

<section data-markdown><script type="text/template">
  ## Never bind to the scope...
</script></section>

<section data-markdown><script type="text/template">
  ## ...bind to an object *on* the scope
</script></section>

<section data-markdown><script type="text/template">
  ## Why?
</script></section>


<section data-markdown><script type="text/template">
  ## TO ESCAPE THE GHOSTS!!!
</script></section>


<section data-markdown><script type="text/template">
  
  ## Sharing data

  - child's own property will ghost parent's
  - use objects to share data between scopes
</script></section>

<section data-markdown><script type="text/template">
  ## Ghost spotting

  ```
  var parent = {
    title: "app", 
    user: {name: "bob"}
  };
  var child = Object.create(parent)
  child.title // 'app'

  parent.title = 'fancy app'
  child.title // 'fancy app'

  child.title = 'child'
  parent.title // 'changed again'
  child.title // 'child'
  // we lost link - child now has its own 'title' property

  child.user.name = 'sue'
  child.user.name  // what'll it be?
  parent.user.name  // and here?
  ```

</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's try that out

  - exercises/tricky-scopes


</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Scope life-cycle

  - scopes don't live forever
  - e.g in a `ng-repeat` when item is deleted
  - listen to `$destroy` event
  - make sure you clean up times etc!
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## listen you say?
</script></section>

<section data-markdown  data-tags=inside data-state=title><script type="text/template">
  ## Scope's pubSub
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$emit` and `$broadcast`
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$emit`
   
  - triggers event on current scope and then back up to root
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## `$broadcast`

  - like `$digest`, current scope and down
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Using pubSub

  - more like DOM events than other systems
  - can cancel, see current/target scope etc

  ```javascript
  app.controller("video",function($scope) {
    $scope.$watch = function(video) {
      // up 
      $scope.$emit("watched",video.id);
      // down
      $scope.$broadcast("watched",video.id);
    }
  })
  ```

  ```javascript
  app.controller("watchCount",function($scope) {
    var counts = {};
    $scope.$on("watched",function(event,id) {
      counts[id] = (counts[id] || 0) + 1;
    })
  })
  ```

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## How to use

  - I'd suggest: for very scope dependent things
  - e.g no need for controllers to care where event came from
  - For more general use, pick a simpler/faster option

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## So back to `$destroy`

  ```javascript
  app.controller("watchCount",function($scope,$interval) {
    var tick = $interval(function() {
      // $scope isn't getting GC'd until this
      // function is
    },500);
    $scope.$on("$destroy",function() {
      // frees the callback, and therefore the $scope
      $interval.cancel(tick);
    })
  })
  ```
  

</script></section>




<section data-markdown data-state=title><script type="text/template">
  
  ## No tests?!

</script></section>

<section data-markdown><script type="text/template">
  
  ## Testing

  - unit testing: isolation
  - end to end testing: integration/functional
  - this is where dependency-injection comes in handy!

</script></section>

<section data-markdown><script type="text/template">
  
  ## Unit tests

  - test one unit of functionality in isolation
  - stub out dependencies for speed/simplicity of testing

  ```
  // app code
  var app = angular.module("app",[]);
  app.filter("first",function(xs) { return xs[0] });

  // test code
  describe("myFilter",function() {
    // setup our injector with the module we want
    beforeEach(module("app"))
    // wrap test code with injector to get at our code
    it("should only return first",inject(function(first) {
      expect(first("hello")).toEqual("h");
    })
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## Testing: tools

  - test framework: mocha, Jasmine
  - test server/runner: Karma
  - assertions: chai, referree

</script></section>

<section data-markdown><script type="text/template">
  ## For today
  - Jasmine, test framework, runner and assertions
  - BDD style for assertions and suite
</script></section>

<section data-markdown><script type="text/template">
  ## What does Angular change?
</script></section>

<section data-markdown><script type="text/template">
  ## How we wrap our code
</script></section>

<section data-markdown><script type="text/template">
  ## So... how do we unwrap it?
</script></section>

<section data-markdown><script type="text/template">
  
  ## `module()`

  - sets up injector to include module(s)
  - or to stub dependencies

  ```
  var moduleSettingFunction = module("app")
  module("app",function($provide) {
    // here we use $provide just like our module
    // allowing us to override factories, values etc
    $provide.value("something",override);
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## `inject()`

  - runs function with dependencies taken from module(s)

</script></section>

<section data-markdown><script type="text/template">
  ## What do we want to inject?
</script></section>

<section data-markdown><script type="text/template">
  ## Fake versions of services
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks n stubs
</script></section>

<section data-markdown><script type="text/template">
  ## Both fakes
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks: function voyeurism

  ```javascript
  var spy = Jasmine.createSpy("spyName");
  spy("Howdy!!!");
  expect(spy).toHaveBeenCalledWith("hello");
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks: asserting call behaviour
</script></section>

<section data-markdown><script type="text/template">
  ## Stubs

  - replace dependencies of a unit

  ```javascript
  function simpleCode(getAnswerFromTelescope) {
    var number = getAnswerFromTelescope();
    // we just want to test this bit
    return number + 1;
  }
  function getAnswerFromTelescope() {
    // horribly slow
    // non-deterministic
    return 42;
  }

  expect(simpleCode(function() { return 1 })).toBe(2)
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Mocks are tests, stubs support tests
</script></section>

<section data-markdown><script type="text/template">
  ## Both are fakes
</script></section>

<section data-markdown><script type="text/template">
  
  ## Let's test drive something

  - implement a tracking system
  - `event(eventName)` counts the number of times its invoked with a given event
  - `save()` fires a `HTTP POST` with the currently tracked events

  ```javascript
  app.controller("user",function($scope,tracking,$interval) {
    $scope.$watch = function() {
      tracking.event("watch");
    }
    $interval(function() {
      tracking.save();
    },5000);
  });
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## You'll want to mock out `$http`
</script></section>


<section data-markdown data-state=highlight><script type="text/template">
  ## Your first test

  - exercises/first-test

</script></section>

<section data-markdown><script type="text/template">
  ## That wasn't very radical
</script></section>

<section data-markdown><script type="text/template">
  ## ...what about the hard parts?
</script></section>

<section data-markdown><script type="text/template">
  ## OK... how about controllers?
</script></section>

<section data-markdown><script type="text/template">
  ## Testing controllers
  ```javascript
  describe("drawingListItem controller",function() {
    var controller;
    var $scope;

    beforeEach(inject(function($rootScope,$controller) {
      $scope = $rootScope.$new();

      controller = $controller('drawingListItem',{
        $scope: $scope
      });
      $scope.$apply();
    }));

    it('saves drawing after the name has been changed', inject(function($q) {
      spyOn($scope.drawing,"$save").andReturn($q.when(true));
      $scope.$apply(function() {
        $scope.drawing.name = "foo";
      }); 
      expect($scope.drawing.$save).toHaveBeenCalled();
    }));
  });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## If your controllers don't talk to DOM...
</script></section>

<section data-markdown><script type="text/template">
  ## ...testing them is easy
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Testing Directives
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## What's required?

  - compile a template containing our directive
  - get access to the `scope` so we can set data/fire events
  - check if directive worked
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Testing directives

  ```javascript 
  describe("notifications",function() {
    var $compile;
    var $rootScope;

    beforeEach(inject(function(_$rootScope_,_$compile_) {
      $compile = _$compile_; // _aService_ avoids shadowing var aService
      $rootScope = _$rootScope_;
    }));

    it("sets the message as visible on notify",function(notifications) {
      var el = $compile("<div><div notifications></div></div>")($rootScope);
      
      $rootScope.$broadcast("notify","something");
      $rootScope.$apply();
      
      expect(el.find(".notification-content.ng-hide").length)
        .toBe(0,"should be visible");
    });
  });
  ```

</script></section>

















<section data-markdown><script type="text/template">
  
  ## Next steps

  - Rebuild TodoMVC, or other small CRUD project
  - UI router
  - Release a custom directive

</script></section>


<section data-markdown data-state=title><script type="text/template">
  
  # That's a wrap!

</script></section>


<section data-markdown data-state=highlight><script type="text/template">

  ## Thanks!

  <br />
  <br />
  <br />

  ### @timruffles

</script></section>


</div>
</div>

<script>
if(qString()["prune"]) {
  pruneOutByTag.apply(null, qString()["prune"].split(","));
}
function qString() {
  return location.search.substr(1).replace(/\/$/,'').split("&").reduce(function(all,pair) {
    pair = pair.split("=");
    all[pair[0]] = pair[1];
    return all;
  }, {});
}
function pruneOutByTag() {
  [].slice.call(arguments).forEach(function(tag) {
    [].forEach.call(document.querySelectorAll("section[data-tags*=" + tag + "]"),function(el) {
      el.parentElement.removeChild(el);
    });
  });
}
</script>

<script src="angular.js"></script>
<script src="demo.js"></script>
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>

  var hljsDeferred;
  var hljsPromise;
  var mdDeferred;
  var mdPromise;

  angular.injector(["ng"]).invoke(function($q) {
    hljsDeferred = $q.defer();
    hljsPromise = hljsDeferred.promise;
    mdDeferred = $q.defer();
    mdPromise = mdDeferred.promise;
  });

  Reveal.initialize({

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
        { src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); }, callback: mdDeferred.resolve },

        // Syntareveal/x highlight for <code> elements
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { 
              hljs.initHighlightingOnLoad(); 
              hljsDeferred.resolve();
          } },

        // Zoom reveal/in and out with Alt+click
        { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speakreveal/er notes
        { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remotreveal/e control your reveal.js presentation using a touch device
        // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
    ]

  });

  Reveal.addEventListener( 'ready', function( event ) {
    angular.injector(["ng"]).invoke(function($q) {
      // bootstrap the slides after they've been markdown compiled
      $q.all([hljsPromise,mdPromise]).then(function() {
        angular.bootstrap(document.body,["slides"]);
        angular.injector(["ng","slides"]).invoke(function($compile,$rootScope) {
          [].forEach.call(document.querySelectorAll("section[data-markdown]"),function(slide) {
            $compile(slide)($rootScope)
          })
        })
      })
    })
  });
  
</script>
</body>
</html>
