<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">  
    <title>AngularJS</title>
    <link rel="stylesheet" href="reveal/css/reveal.css">
    <!-- <link rel="stylesheet" href="reveal/css/print/pdf.css"> -->

    <meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="reveal/css/reveal.min.css">
    <link rel="stylesheet" href="reveal/lib/css/github.css">

    <link rel="stylesheet" href="slides-theme/style.css">
    <link rel="stylesheet" href="style.css">
</head>

<body>

<div class="reveal">
<div class="slides">

<section data-markdown data-state="highlight"><script type="text/template">

  # AngularJS
  ![shield](img/angular-shield.svg)

</script>
</section>

<section data-markdown><script type="text/template">
  <h3 style='text-transform:inherit' contenteditable>wifi: ??? / ???</h3>
  <h3 contenteditable> clone/DL: github.com/timruffles/angular-js-class</h3>
</script>
</section>

<section data-markdown data-state=title><script type="text/template">

  ## Day two

</script></section>

<section data-markdown><script type="text/template">

  ## Today

  - scopes
  - lifecycle + pubSub
  - testing
  - application structure
  - animations
  - promise redux
  - i18n
  - directives
  - measuring performance

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## How do scopes work?
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## Scopes: power data-binding
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Two big features

  1. can share data with children
  1. magically know when data changes

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ...but how?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Sharing data

  ```javascript
  function MailCtrl(Mailbox, $scope) {
    $scope.mailboxes = Mailbox.all();
    $scope.selectMailbox = function(mb) {
      // ...
    }
  }
  ```
  ```html
    <div ng-controller='MailCtrl'>

      <nav ng-controller='NavCtrl'>
        <a ng-repeat='mailbox in mailboxes'
           ng-click="selectMailbox(mailbox)">Social</a>
      </nav>

      <div ng-controller='MessageCtrl'>
        <p ng-repeat="message in mailbox.messages">
          {{ message.from }} - {{ message.subject }}
        </p>
      </div>

    </div>
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Hierarchy

  - what else in JS have parent/child relationships?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Objects!

  - the prototype chain
</script></section>

<section data-markdown><script type="text/template">

  ## Scopes are just objects

  - scopes prototypally inherit from parents
  - this makes for intuitive cooperation between controllers

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Prototypal inheritance

  ```
  var parent = {
    title: "Our lovely app", 
    user: {name: "bob"}
  };
  var child = Object.create(parent)

  child.title // "Our lovely app"
  child.user === parent.user // true
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Never bind to the scope...
</script></section>

<section data-markdown><script type="text/template">
  ## ...bind to an object *on* the scope
</script></section>

<section data-markdown><script type="text/template">
  ## Why?
</script></section>

<section data-markdown><script type="text/template">
  
  ## Sharing data

  - child's own property will ghost parent's
  - use objects to share data between scopes
</script></section>

<section data-markdown><script type="text/template">
  ## Ghost spotting

  ```
  var parent = {
    title: "app"
  };
  var child = Object.create(parent)

  child.title // 'app'

  parent.title = 'fancy app'
  child.title // 'fancy app'

  child.title = 'child'
  parent.title // 'fancy app'
  // we lost link - child now has its own 'title' property
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Ghost spotting

  ```
  var parent = {
    title: "app"
  };
  var child = Object.create(parent)

  child.user.name = 'sue'

  child.user.name   // what'll it be?
  parent.user.name  // and here?
  ```

</script></section>

<section data-state=title data-markdown data-tags=inside><script type="text/template">
  ## Data-binding
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## How?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `scope.$watch()`

  - all binding goes via `$watch()` internally

  ```javascript
  scope.$watch("user.name",function(newValue,old) {
    // run only when value changes
  });

  scope.$watch(function() {
    // same functionality as above
    return scope.user.name;
  },function(newValue,old) {
    // run only when value changes
  });
  ```

  ```html
    <a>{{ user.name }}</a>
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `scope.$watch()`

  - defaults to `===`
  - pass `true` to third argument for deep comparison
  - deep uses `angular.copy` to cache objects, so if poss only watch scalars for speed/space

  ```javascript
  // 'eq' means deep, so you can see it copies to store last value
  watch.last = watch.eq ? copy(value) : value;
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## `$watch`<br>`Collection()`

  - when watching items in a key-value or ordered collection
  - shallow watches: therefore fires on add, delete and reorder

  ```javascript
  scope.$watchCollection("usersById", handler);
  scope.$watchCollection("user.messages", handler);
  ```

</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## Synchronising via watchers
</script></section>


<section data-markdown  data-tags=inside><script type="text/template">

  ## Running exercises

  ### OSX

  ```sh
  cd exercises
  python -m SimpleHTTPServer
  ```

  ### Windows (or other)

  - run `nodejs.org/download` installer as admin, asking for npm to be installed

  ```sh
  npm install -g node-static
  cd exercises
  static
  ```

</script></section>

<section data-markdown  data-tags=inside data-state=highlight><script type="text/template">

  ## Let's do some watching

  - exercises/watching-scope

</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## So when do the watchers fire?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## When you tell them to
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## When would we want watchers to fire?

  - when something has happened that affected scope
  - e.g click handler, async callback etc

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Triggering watchers

  - process known in Angular as 'digest loop'

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Digest loop

  - the process of checking all watchers
  - if value of expression has changed, fires handler
  - handlers update bindings - e.g for `<a ng-repeat='user in users'></a>`

</script></section>


<section data-markdown data-tags=inside><script type="text/template">

  ## `$digest()`

  ```javascript
  scope.show = true;

  scope.$watch("show", function(yes) {
    console.log("showing: " + (yes ? "yes" : "no"))
  });

  scope.show = false;
  scope.show = true;
  scope.show = false;

  // how many times would we see console log?
  ```

</script></section>

<section data-tags=inside data-markdown><script type="text/template">
  ## Till now, fired by angular
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## What's Angular doing here?

  ```html
    <a ng-click='story.likes += 1'>Plus one</a>
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## What's Angular doing here?

  - running the digest loop after evaluation the expression

  ```html
    <a ng-click='story.likes += 1'>Plus one</a>
  ```

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## ng-world, JS-world

  - if we make changes to scope outside of Angular's world we'll need to tell Angular

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## JS-world

  ```javascript
  function someDirective() {
    // ...
    function load() {
      d3.jsonp("some-lovely.jsonp", function(data) {
        // Angular has no idea this code has run
        scope.series = data;
      });
    }
  }
  ```


</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## When do we need to tell Angular?
  - e.g DOM or AJAX callback, non-Angular event callback
  - very important when writing your own directives
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## How?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$digest()` and `$apply()`

  - both `Scope` methods
  - usually use `$apply()`
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## `$digest`: scope downwards
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## `$apply`: `$rootScope` downwards
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ![digest](img/digest.png)
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ![apply](img/apply.png)
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## `$apply`

  - usually used for custom directives
  - covers any change to scopes
  - handles errors in expressions
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## `$apply` manually

  ```javascript
  scope.$apply(function() {
    // pass function so we catch errors
    // ... make changes to scope
    scope.user.score = score.caluate(scope.user);
  });
  ```
</script></section>

<section  data-tags=inside data-markdown><script type="text/template">
  ## `$apply` use

  - to link up angular/js worlds
  - DOM handlers etc for directives
  - otherwise, async APIs from other sources
  - e.g libraries, `IndexedDB` etc
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Pseudo-code

  - note the `$exceptionHandler`

  ```javascript
  function $apply(expr) {
    try {
      return $eval(expr);
    } catch (e) {
      $exceptionHandler(e);
    } finally {
      $root.$digest();
    }
  }
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$exception` <br> `Handler`

  - by default just logs
  - can override - e.g with a gmail style error notifier
  - consumers of custom directives will expect it
</script></section>

<section data-markdown data-state=highlight><script type="text/template">
  
  # Let's try that out

  - exercises/tricky-scopes


</script></section>


<section data-markdown  data-tags=inside data-state=title><script type="text/template">
  ## Scope's pubSub
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$emit` and `$broadcast`
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## `$emit`
   
  - triggers event on current scope and then back up to root
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## `$broadcast`

  - like `$digest`, current scope and down
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Using pubSub

  - more like DOM events than other systems
  - can cancel, see current/target scope etc
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## API

  ```javascript
  module.controller("video",function($scope) {
    $scope.$watch = function(video) {
      // up 
      $scope.$emit("watched",video.id);
      // down
      $scope.$broadcast("watched",video.id);
    }
  })
  ```

  ```javascript
  module.controller("watchCount",function($scope) {
    var counts = {};
    $scope.$on("watched",function(event,id) {
      counts[id] = (counts[id] || 0) + 1;
    })
  })
  ```
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## How to use

  - I'd suggest: keep to view notifications only
  - for more general use, pick a simpler/faster option

</script></section>


<section data-markdown data-state=title><script type="text/template">
  ## Lifecycle &amp; pubSub
</script></section>

<section data-markdown ><script type="text/template">
  ## Lifecycle

  - AngularJS scopes need to be GC'd like everything else
  - to control this we'll need to learn about events

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Scope life-cycle

  - scopes don't live forever
  - e.g in a `ng-repeat` when item is deleted
  - listen to `$destroy` event
  - make sure you clean up times etc!
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  
  ## Handling `$destroy`

  ```javascript
  module.controller("watchCount",function($scope,$interval) {
    var tick = $interval(function() {
      // $scope isn't getting GC'd until this
      // function is
    },500);
    $scope.$on("$destroy",function() {
      // frees the callback, and therefore the $scope
      $interval.cancel(tick);
    })
  })
  ```

</script></section>

<section data-state=title data-markdown><script type="text/template">
  
  ## Directives in Angular

</script></section>



<section data-markdown><script type="text/template">
  
  ## Directives in Angular

  - All the cool bits are from directives
  - `ngRepeat`, `ngInclude`, `ngClick` etc all directives

</script></section>

<section data-markdown><script type="text/template">
  ## You have the power
  - No private APIs: all tools available to `ng` is available to you
</script></section>


<section data-markdown><script type="text/template">
  
  ## Defining

  - defined on modules as normal
  - return either a config object

</script></section>

<section data-markdown><script type="text/template">
  
  ## Define example

  ```javascript
  module.directive("someName",function($location /* injected */) {
    return {
      link: function(scope,el,attrs) {
      }
    }
  });

  // shorthand for when only link required
  module.directive("someName",function($location /* injected */) {
    return function(scope,el,attrs) {
    }
  });
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## Linking function

  - positional arguments, not DI (use the containing function for that)

  ```javascript
  function link(scope, el, attrs) {
  }
  ```

</script></section>


<section data-markdown><script type="text/template">
  ## `scope`

  - the scope the element is in

  ```javascript
  function link(scope, el, attrs) {
    scope.someProperty = "hello";
  }
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `el`

  - the element wrapped in `angular.element()`

  ```javascript
  function link(scope, el, attrs) {
    el.addClass("hello");
  }
  ```
</script></section>


<section data-markdown><script type="text/template">
  ## `angular`<br>`.element()`

  - jqLite by default - a subset of jQuery API
  - include jQuery, it automagically becomes jQuery!

</script></section>

<section data-markdown><script type="text/template">
  ## `attrs`

  - normalised attribute names, e.g `some-attr` -> `someAttr`
  - methods: `$set('normalisedName', value)` etc

  ```javascript
  function link(scope, el, attrs) {
    // from...
    // some:attr some-attr data-some-attr x-some-attr
    var attr = attrs.someAttr;
  }
  ```
</script></section>
  
<section data-markdown data-tags=inside><script type="text/template">
  ## ...what are isolate scopes?
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directive scopes

  - need to control level of sharing with parent
  - default: shares parent scope
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Parent visibility

  - in config, `scope: true` to create a new child scope
  - pass a `scope: {}`, create an isolate scope

</script></section>


<section data-markdown data-tags=inside><script type="text/template">

  ## Three ways to interact with parent scope

</script></section>


<section data-markdown data-tags=inside><script type="text/template">

  ## Two way

  - shallow: `=*`

  ```javascript
  scope: {
     // 2 way binding between localName and name
    "model": "=ngModel",
  }, 
  link: function(scope) {
    scope.model = "new name" // updates user.name
  }
  ```

  ```html
  <input name=username ng-model='user.name'>
  ```




</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Attribute

  ```javascript
  scope: {
     // 2 way binding between localName and name
    "title": "@title",
  },
  link: function(scope) {
    scope.title // "Hello bob"
  }
  ```

  ```html
  <panel title="Hello {{ user.name }}"></panel>
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Expression

  ```javascript
  scope: {
     // 2 way binding between localName and name
    "done": "&done",
  },
  link: function(scope) {
    scope.done() // calls onDimissed()
  }
  ```

  ```html
  <panel done="onDimissed()"></panel>
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Weird symbols

  ```javascript
  scope: {
     // 2 way binding between localName and name
    "localName": "=name",
    // live binding to href on directive's DOM el 
    "href": "@href", 
     // provides a function wrapper for an expression
    "dyanmic": "&someExpression"
  }
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Transclusion
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## ARRRRRGH! 

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Not scary
  - Actually pretty simple: function to clone & comile a chunk of DOM
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Intuitive

  ```html
    <li ng-repeat='story in stories'>
      <p>I am transcluded {{ story.name }}</p>
    </li>

    <div transclude-demo>
      <h2>I'll be inside a section soon</h2>
      <p>I can bring {{ stories.length }} with me</p>
    </div>
  ```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Transclusion example

  ```javascript
  module.directive("transcludeDemo",function() {
    return {
      transclude: "element",
      template: "<section><div ng-transclude></div></section>",
      compile: function data-tags=inside(el,attr,transcludeLink) {
        return function link(scope,el,attrs,controller) {
        }
      }
    }
  });
  ```

</script></section>


<section data-markdown  data-state=highlight><script type="text/template">
  
  ## Exercise

  - exercises/scopes-and-directives

</script></section>


<section data-state=title data-markdown data-tags=inside><script type="text/template">
  ## Directive controllers
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directive controllers

  - directives can need controllers too
  - allows multiple directives to communicate & share a parent
  - allows you to create extensible directives
  - same job: expose behaviour to scope

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
## Example

```javascript
  module.directive("tour",function() {
      return {
        controller: function($scope) {
          // normal controller code - nothing
          // related to DOM
        }
      }
  });

  module.directive("tourStep",function() {
      return {
        // prefix like '^' controls where controller is
        // looked for: so here looking up DOM to find a directive 
        // called 'tour' with a controller defined
        require: "^tour",
        link: function(scope,el,attrs,controller) {
          // fourth argument becomes our controller
        }
      }
  });
```

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  
  ## Directive controllers

  - most commonly used: `ngModelController`

</script></section>

<section data-markdown data-state=title><script type="text/template">
  
  ## Testing directives & controllers

</script></section>

<section data-markdown><script type="text/template">
  
  ## Testing

  - unit testing: isolation
  - end to end testing: integration/functional
  - this is where dependency-injection comes in handy!

</script></section>

<section data-markdown><script type="text/template">
  
  ## Unit tests

  - test one unit of functionality in isolation
  - stub out dependencies for speed/simplicity of testing

</script></section>


<section data-markdown><script type="text/template">
  ## Tools
  - Jasmine, test framework, runner and assertions
  - BDD style for assertions and suite
</script></section>

<section data-markdown><script type="text/template">
  ## What does Angular change?
</script></section>

<section data-markdown><script type="text/template">
  ## How we wrap our code
</script></section>

<section data-markdown><script type="text/template">
  ## So... how do we unwrap it?
</script></section>

<section data-markdown><script type="text/template">
  
  ## `module()`

  - sets up injector to include module(s)
  - or to stub dependencies

  ```javascript
  var moduleSettingFunction = module("app")
  ```

  ```javascript
  beforeEach(module("app"));
  ```

</script></section>

<section data-markdown><script type="text/template">
  
  ## `module()` for stubs

  ```javascript
  module("app",function($provide) {
    // here we use $provide just like our module
    // allowing us to override factories, values etc
    $provide.value("something",override);
  })
  ```

</script></section>


<section data-markdown><script type="text/template">
  
  ## `inject()`

  - runs function with dependencies taken from module(s)

</script></section>


<section data-markdown><script type="text/template">
  ## Get at code
  ```javascript
  // app code
  angular.module("app",[])
  .filter("first",function() {
    return first;
  });

  function first(xs) {
    return xs[0]
  }
  ```

  ```javascript

  // test code
  describe("myFilter",function() {

    // setup our injector with the module we want
    beforeEach(module("app"))

    // wrap test code with injector to get at our code
    it("should only return first",inject(function($filter) {
      var first = $filter("first");
      expect(first("hello")).toEqual("h");
    })
  })
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Check

  - testing in general
  - Jasmine
  - spies/mocks

</script></section>



<section data-markdown><script type="text/template">
  ## Testing controllers
</script></section>

<section data-markdown><script type="text/template">
  ## Setup
```javascript
  // this is similar for most controller tests
  beforeEach(inject(function($rootScope,$controller) {

    // a scope for us to use, can pass object to $new()
    $scope = $rootScope.$new({
      todos: []
    });

    // instantiate our controller
    controller = $controller('TodoForm',{
      $scope: $scope
    });

    // any watchers setup in constructor
    $scope.$apply();
  }));
```
</script></section>

<section data-markdown><script type="text/template">
  ## If your controllers don't talk to DOM...
</script></section>

<section data-markdown><script type="text/template">
  ## ...testing them is easy
</script></section>

<section data-markdown><script type="text/template">
  ```javascript
  // testing a controller method itself
  it('handles  submission', function() {
    controller.add({ message: "get milk" });
    expect($scope.todos).toContain({ message: "get milk" });
  });

  // testing a method controller adds to scope
  it("publishes a method that filters valid todos", function() {
    expect($scope.validTodo({ message: "" })).toBeFalse();
  });
  ```
</script></section>


<section data-markdown data-state=title><script type="text/template">
  ## Let's try

  - `exercises/testing-controllers`

</script></section>


<section data-markdown ><script type="text/template">
  ## Testing Directives
</script></section>

<section  data-markdown><script type="text/template">
  ## What's required?

  - compile a template containing our directive
  - get access to the `scope` so we can set data/fire events
  - check if directive worked
</script></section>

<section data-markdown ><script type="text/template">
  ## Setup

  ```javascript 
  var scope = $rootScope.$new({
    some: "data"
  });

  var createEl = $compile("<div><div notifications></div></div>");
  var el = createEl(scope);
  ```
</script></section>

<section data-markdown ><script type="text/template">
  ## Normal DOM unit-testing

  - jQuery is your friend - synthetic events etc

  ```javascript 
  it("reveals on click", function() {

    // setup spies
    // ...

    // fire DOM event
    el.find(".show-me").click()
  });
  ```
</script></section>

<section data-markdown ><script type="text/template">
  ## Complete test

  ```javascript 
  it("reveals notification content on notify", 
    inject(function($rootScope, $compile, notifications) {

      var scope = $rootScope.$new({
        some: "data"
      });

      var createEl = $compile("<div><div notifications></div></div>");
      var el = createEl(scope);
      
      $rootScope.$broadcast("notify","something");
      
      expect(el.find(".notification-content.ng-hide").length)
        .toBe(0, "should be visible");

  }));
  ```
</script></section>


<section data-markdown data-state=title><script type="text/template">
  ## Let's try

  - `exercises/testing-directives`

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## Custom inputs and advanced forms
</script></section>


<section data-markdown><script type="text/template">
  ## Quick refresher on `form`

  - `form` + `name=` puts an object with form API on scope
  - `ng-model` + `name=` puts a object on form object
  - both have attrs/methods on state: e.g `$valid` and `$pristine`
  
</script></section>

<section data-markdown><script type="text/template">
  ## `ngModelController`
  
  - complete system for handling inputs
  - using `ngModelController` you can turn anything into an input
</script></section>

<section data-markdown><script type="text/template">
  ## `ngModelController`
  
  - `$setViewValue`
  - `$parsers` chain
  - `$validators` chain
  - from model goes via `$formatters` chain
  - `$render()` to display
</script></section>

<section data-markdown><script type="text/template">
  ## Getting it

  - normal `require` API
  
  ```javascript
  module.directive("humanDate", function() {
    return {
      require: "ngModel",
      link: function(scope, el, attrs, ngModel) {
        // ngModel is controller instance
      }
    }
  });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$setViewValue()`
  
  ```javascript
  el.on("input", function(event) {
    ngModelCtrl.$setViewValue(el.val(), event);
  });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$parsers`

  - an array of functions
  - overwrite or `push()`
  - reverse order - push to front of queue
  
  ```javascript
  link: functions(scope, el, attrs, ngModel) {
    ngModel.$parsers.push(function(v) {
      return humanToDate(v);
    });
  }
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## `$validators`

  - a key value object
  - keys become `ng-invalid-{validator-name}` classes
  - and properties of `someForm.someInput.$errors`
  
  ```javascript
  link: functions(scope, el, attrs, ngModel) {
    ngModel.$validators.parsable = canParse;
  }
  ```
</script></section>


<section data-markdown><script type="text/template">
  ## `$formatters`

  - format to string value for `$render`
  - reverse order - push to front of queue
  
  ```javascript
  link: functions(scope, el, attrs, ngModel) {
    ngModel.$validators.parsable = canParse;
  }
  ```
</script></section>

  
<section data-markdown><script type="text/template">
  ## Exercise

  `exercises/advanced-forms`
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## Promises
</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## An IOU

  - A promise is a value, returned immediately
  - Later fulfilled or rejected - once
  - Can use before or after value arrives
  - Chain promises together

</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Intuition

  ![Promise chain](img/promises.png)

</script></section>

<section data-markdown data-tags=inside><script type="text/template">

  ## Promises in practice

  - `.then()` with a function that accepts the value when it arrives
  - `.then()` returns a new promise - for the return value of the function

  ```javascript
  var user = getUser(params["id"]);
  var profile = user.then(getProfile);
  var accountPage = Promise.spread(user,profile).then(accountPageTemplate);

  accountPage.then(
    renderToDom,
    renderErrorMessage
  );
  ```

</script></section>


<section data-markdown data-tags=inside><script type="text/template">

  ## `then` is either:

  - An action to take when promise settles
  - A recipe for a new promised value

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## Angular's promises

  - `$q` - is to `Q` as `jQLite` is to `jQuery`

  ```javascript
  var tenner = $q(function(resolve, reject) {
    // some non-promise code
    setTimeout(function() {
      resolve("£10");
    }, 500);
  });
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Promise tools

  ```javascript
   // returns a promise, if x is:
   // - a non-promise, a resolved promise for x
   // - a promise, that promise
  $q.when(x)

  // a rejected promise
  $q.reject(x)

  // a promise for an array/object with all resolved
  // promises values
  $q.all([promise, value, promiseB, valueB])
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Promise flow control

  ```javascript
  SomeQuery
    .then(transform)
    .then(function(value) {
      if(!isOk(value)) {
        throw new Error("Not ok!")
      }
      if(someTest(value)) {
        return QueryA(value)
      } else {
        return QueryB(value)
      }
    })
    .catch(function(err) {
      throw new Error("Our query failed: " + err);
    })
    .finally(function() {
      // anything that happens if resolved/rejected
    });
  ```
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Promises + collections

  ```javascript
  var userIds = [10,20,30,50,100];

  // array of promises
  var users = userIds.map(User.get);

  // promise for array of {user, account}
  var usersWithAccounts = $q.all(users)
    .then(function(users) {
      return users.map(function(user) {
        return $q.all({
          user: user,
          account: Account.get(user)
        });
      });
    });
  ```
</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## Promises conclusion

  - promises give us values for async code
  - don't just use as callbacks
  - think about transformers for the values
  - link related promises together

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## Let's try

  - exercises/http

</script></section>
  
<section data-markdown data-state=title><script type="text/template">
  ## Application structure
</script></section>

<section data-markdown><script type="text/template">
  ## Folder/module structure
</script></section>

<section data-markdown><script type="text/template">
  ## Two main patterns
</script></section>

<section data-markdown><script type="text/template">
  ## Type folders

  ```
  app
    controllers
    services
    directives
  ```

</script></section>


<section data-markdown><script type="text/template">
  ## Feature folders

  ```
  app
    account
    checkout
    dashboard
    chat
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## Which scales?
</script></section>

<section data-markdown><script type="text/template">
  ## Feature folders

  - atomic chunks
  - cohesive
  - lazy-loadable
</script></section>

<section data-markdown><script type="text/template">
  ## Data-visibility
</script></section>

<section data-markdown><script type="text/template">
  ## Global variables
</script></section>

<section data-markdown><script type="text/template">
  ## Why are they bad?
</script></section>

<section data-markdown><script type="text/template">
  ## Not all created equal
</script></section>

<section data-markdown><script type="text/template">
  ## *Mutable* global variables

  - `window.user.name = "sue"`
  - hard to know where that occured
</script></section>


<section data-markdown><script type="text/template">
  ## Global variables

  - testing? not so much with JS
  - reasoning
</script></section>

<section data-markdown><script type="text/template">
  ## Mutable globals in ng I

  - visible from any service/controller/directive
  - no control

  ```javascript
  module.factory("Card", function() {
    return {
      number: null,
      cvs: null,
    }
  });
  ```
</script></section>

<section data-markdown><script type="text/template">
  ## Mutable globals in ng II

  - a big hammer
  - is it *really* app-wide?

  ```javascript
  module.controller("SomeCtrl", function($rootScope, Checkout) {
    $rootScope.checkout = Checkout;
  });
  ```
</script></section>


<section data-markdown><script type="text/template">
  ## Small controllers

  - controllers are modules/classes
  - big modules/classes likely to be
    - confused (too many jobs)
    - hard to maintain
</script></section>

<section data-markdown><script type="text/template">
  ## Use teams of controllers

  - each with a small job
  - share data only if necessary
  - easier to test, debug, understand
  - use `SomeCtrl as someCtrl` syntax
</script></section>

<section>
  <h2>Example</h2>
  <img src=img/gmail.png>
</section>

<section data-markdown><script type="text/template">

  ```html
    <div ng-controller='InboxCtrl as inboxCtrl'>
      <nav ng-controller='NavCtrl as navCtrl'>
        <a ng-click="inboxCtrl.select('primary')">Primary</a>
        <a ng-click="inboxCtrl.select('social')">Social</a>
      </nav>
      <div ng-controller='MessageCtrl as msgCtrl'>
        <ul>
          <li ng-repeat="message in inboxCtrl.mailbox.messages">
            {{ message.from }} - {{ message.subject }}
          </li>
        </ul>
      </div>
    </div>
  ```

</script></section>
  


<section data-markdown><script type="text/template">

  ## System of controllers

  ```javascript
    function InboxCtrl($scope, Mailbox) {
      this.select = function(id) {
        this.mailbox = Mailbox.get(id)
      }
      this.select("primary")
    }
    function MessageCtrl($scope) {
      // message specific behaviour
    }
    function NavCtrl($scope) {
      // nav specific behaviour... no god objects here
    }
  ```
</script></section>

<section data-markdown><script type="text/template">

  ## Eyebrow raises

  - controllers > ~ 100 LOC
  - > ~10 methods
  - they're just glue, so keep small'n'simple

</script></section>

<section data-markdown><script type="text/template">

  ## Where to extract?

  - is it actually domain logic? models
  - is it persisting (anywhere)? persistence
  - is it formatting? filter/service
  - complex logic? helper nouns/verbs

</script></section>


<section data-markdown><script type="text/template">

  ## Scope is a public API

  - sharing methods with children
  - sharing methods with view
  - don't expose anything not required!

</script></section>

<section data-markdown><script type="text/template">

  ## Function-locations

  ```javascript
    function InboxCtrl($scope, Mailbox, Spam) {

      var controllerPrivateVar = 10;

      function controllerPrivateMethod() {
      }
    }
  ```

</script></section>

<section data-markdown><script type="text/template">

  ## Controller properties

  - remember, controllers are constructors!

  ```javascript
    function InboxCtrl($scope, Mailbox, Spam) {
    }

    InboxCtrl.properties.controllerMethod = function() {
    }
  ```

</script></section>

<section data-markdown><script type="text/template">

  ## When to use?

  - I stick with locals in 90% of cases
  - Controller methods for coordinating controllers

</script></section>



  
<section data-markdown data-state=title><script type="text/template">
  ## Animations
</script></section>

<section data-markdown><script type="text/template">
  ## `ng-animate`

  - optional module, like `ngRoute`
</script></section>

<section data-markdown><script type="text/template">
  ## drop-in
</script></section>

<section data-markdown><script type="text/template">
  ## CSS-driven
</script></section>

<section data-markdown><script type="text/template">
  ## Example: `ng-show` and `ng-hide`

  - both powered via addition of `ng-hide`
  - default style is `.ng-hide { display: none!important; }`

</script></section>

<section data-markdown><script type="text/template">
  ## CSS hooks - addClass

  ```css
  // ON
  // about to arrive
  .notification-content.ng-hide-add

  // transitions should be triggered
  .notification-content.ng-hide-add-active
  .notification-content.ng-hide-add

  // animation done
  .notification-content.ng-hide

  // OFF
  // about to depart

  .notification-content.ng-hide-remove
  .notification-content.ng-hide-remove-active
  .notification-content.ng-hide

  // animation done
  ```

</script></section>


<section data-markdown><script type="text/template">
  ## Simple example

  ```css
  /* override ng-hide's display: none!important */
  .title { display: inline-block!important; }

  /* define length of animation */
  .title.ng-hide-add,
  .title.ng-hide-remove {
    transition: 2s linear all;
    transform-origin: center center; }

  /* hiding applied, define goal of transition */
  .title.ng-hide,
  .title.ng-hide-add-active {
    transform: scale(0); }

  /* hiding removed, return to normal */
  .title.ng-hide-remove-active {
    transform: scale(1); }
  ```

</script></section>

<section data-markdown><script type="text/template">
  ## CSS 'hooks'

  - different for each animation
  - can trigger CSS3 animations as well
</script></section>

<section data-markdown><script type="text/template">
  ## Flexibility

  - even a JS animation option!

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## Let's try

  - exercises/animation

</script></section>


<section data-markdown><script type="text/template">
  ## Angular + inspect
</script></section>

<section data-markdown ><script type="text/template">
  ## Tricks
</script></section>

<section data-markdown ><script type="text/template">
  ## Accessing your services

  - note this is a new injector - e.g not same instance

  ```javascript
  angular.injector(["ng", "yourApp"]).get("User");
  ```
</script></section>


<section data-markdown ><script type="text/template">
  ## Accessing scopes

  - `angular.element().scope()`

</script></section>

<section data-markdown data-state=title><script type="text/template">
  ## i18n
</script></section>

<section data-markdown ><script type="text/template">
  ## Powers filters
  
  - `currency`, `number`, `date`
</script></section>

<section data-markdown ><script type="text/template">
  ## via inclusion
  
  - pick a locale
  - include after `angular.js`
  - build time
</script></section>

<section data-markdown ><script type="text/template">
  ## e.g

  - no more `10/22/2014`, yay!
  
  ```html
  <script src=vendor/angular/angular.js></script>
  <script src=vendor/angular/i18n/angular-locale_en-gb.js></script>
  ```
</script></section>

<section data-markdown ><script type="text/template">
  ## Date
  
  - string constants are localised
  
  ```html
  <span>{{ holiday.start | date:'shortDate' }}</span>
  ```
</script></section>

<section data-markdown ><script type="text/template">
  ## Currency
  
  - defaults to locale
  - can override via passing locale
  
  ```html
  {{ holiday.price | currency }}
  {{ holiday.localPrice | currency:holiday.localCurrency }}
  ```
</script></section>



  
<section data-markdown data-state=title><script type="text/template">
  ## Performance of Angular
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Measure first!

  - premature optimisation is the root of all evil
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## How to measure?

  - dev tools!
  - network + audit
  - timeline
  - flamegraph
  - memory: saw-tooth
</script></section>

 
<section data-markdown data-state=title><script type="text/template">
  ## Exercise

  - grab Angular's homepage
  - profile it!
</script></section>



<section data-markdown data-tags=inside><script type="text/template">
  ## What's slow?

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Work

  - lots of `$watch()`
  - > 2,000 is a Bad Thing® according to ng team

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Complex watches

  - `$watch(bigObj, handler, true)` very expensive
  - recursive comparison each digest
  - new copy each change
  - costly in time & space

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Avoiding watchers I

  - Angular 1.3 easiest solution: one-time binds
  - it's a form of caching, so be careful!
  - `ng-once` and others for 1.2

  <script type=cs code-example>
    {{ ::story.title }}
  </script>
  
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Avoiding watchers II

  - don't use big hammers if you don't need
  - e.g ng-repeat on a complex nav
  - precompile, or just hand-code
  - following creates `nav.length * 4` watchers

    
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Waste watchers

  <script type=cs code-example>
    <nav>
      <a ng-repeat="item in nav" 
         ng-href="{{ item.path }}" 
         ng-attr="{disabled: unauthorised(item)}">
         ng-class="{active: isActive(item)}">
        {{ item.title }}
      </a>
    </nav>
  </script>

</script></section>


<section data-markdown data-tags=inside><script type="text/template">
  ## Avoiding watchers III

  - `$interpolate`
  - for complex strings in DOM, you could create a lot of watchers!
  - use little directives and `$interpolate` to reduces count

  ```javascript
  module.directive("complexRow", function($interpolate) {
    var tpl = $interpolate("<span>{{ item.from | fromFilter }}</span><span>{{ item.subject }}</span>");
    return {
      function(scope, el, attrs) {
        scope.$watch(attrs.item, function(newer, older) {
          el.html(tpl({ item: newer }));
        });
      }
    }
  });
  ```
    
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Too much over wire

  - load in layers
  - e.g homepage shouldn't load in big chart library
  - lazy-loading
  - all standards: gzip, minify
  - minified code still needs to be parsed!
    
</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Lazy-loading

  - not very smooth
  - register additional modules on `$compileProvider` and `$moduleProvider`

</script></section>

<section data-markdown data-tags=inside><script type="text/template">
  ## Disable debug data (1.3)

  - doesn't waste time with CSS + references for debugging
  - can `angular.reloadWithDebugInfo();` at any time

  ```javascript
  module.config(function ($compileProvider) {
    $compileProvider.debugInfoEnabled(false);
  });
  ```
    
</script></section>
 


<section data-markdown data-state=title><script type="text/template">
  
  # That's a wrap!

</script></section>


<section data-markdown data-state=highlight><script type="text/template">

  ## Thanks!

  <br />
  <br />
  <br />

  ### @timruffles

</script></section>


</div>
</div>

<script>
if(qString()["prune"]) {
  pruneOutByTag.apply(null, qString()["prune"].split(","));
}
function qString() {
  return location.search.substr(1).replace(/\/$/,'').split("&").reduce(function(all,pair) {
    pair = pair.split("=");
    all[pair[0]] = pair[1];
    return all;
  }, {});
}
function pruneOutByTag() {
  [].slice.call(arguments).forEach(function(tag) {
    [].forEach.call(document.querySelectorAll("section[data-tags*=" + tag + "]"),function(el) {
      el.parentElement.removeChild(el);
    });
  });
}
</script>

<script src="angular.js"></script>
<script src="demo.js"></script>
<script src="reveal/lib/js/head.min.js"></script>
<script src="reveal/js/reveal.min.js"></script>
<script>

  var hljsDeferred;
  var hljsPromise;
  var mdDeferred;
  var mdPromise;

  angular.injector(["ng"]).invoke(function($q) {
    hljsDeferred = $q.defer();
    hljsPromise = hljsDeferred.promise;
    mdDeferred = $q.defer();
    mdPromise = mdDeferred.promise;
  });

  Reveal.initialize({

    // Display controls in the bottom right corner
    controls: false,

    // Display a presentation progress bar
    progress: true,

    // Push each slide change to the browser history
    history: true,

    // Enable keyboard shortcuts for navigation
    keyboard: true,

    // Enable the slide overview mode
    overview: true,

    // Vertical centering of slides
    center: false,

    // Loop the presentation
    loop: false,

    // Change the presentation direction to be RTL
    rtl: false,

    // Number of milliseconds between automatically proceeding to the
    // next slide, disabled when set to 0, this value can be overwritten
    // by using a data-autoslide attribute on your slides
    autoSlide: 0,

    // Enable slide navigation via mouse wheel
    mouseWheel: false,

    // Apply a 3D roll to links on hover
    rollingLinks: false,

    // Transition style
    transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

    dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interreveal/pret Markdown in <section> elements
        { src: 'reveal/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); }, callback: mdDeferred.resolve },

        // Syntareveal/x highlight for <code> elements
          { src: 'reveal/plugin/highlight/highlight.js', async: true, callback: function() { 
              hljs.initHighlightingOnLoad(); 
              hljsDeferred.resolve();
          } },

        // Zoom reveal/in and out with Alt+click
        { src: 'reveal/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speakreveal/er notes
        { src: 'reveal/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remotreveal/e control your reveal.js presentation using a touch device
        // { src: 'reveal/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
    ]

  });

  Reveal.addEventListener( 'ready', function( event ) {
    angular.injector(["ng"]).invoke(function($q) {
      // bootstrap the slides after they've been markdown compiled
      $q.all([hljsPromise,mdPromise]).then(function() {
        angular.bootstrap(document.body,["slides"]);
        angular.injector(["ng","slides"]).invoke(function($compile,$rootScope) {
          [].forEach.call(document.querySelectorAll("section[data-markdown]"),function(slide) {
            $compile(slide)($rootScope)
          })
        })
      })
    })
  });
  
</script>
</body>
</html>
